{
  "version": 3,
  "sources": ["../three/examples/jsm/loaders/GLTFLoader.js"],
  "sourcesContent": ["import {\r\n\tAnimationClip,\r\n\tBone,\r\n\tBox3,\r\n\tBufferAttribute,\r\n\tBufferGeometry,\r\n\tClampToEdgeWrapping,\r\n\tColor,\r\n\tDirectionalLight,\r\n\tDoubleSide,\r\n\tFileLoader,\r\n\tFrontSide,\r\n\tGroup,\r\n\tImageBitmapLoader,\r\n\tInterleavedBuffer,\r\n\tInterleavedBufferAttribute,\r\n\tInterpolant,\r\n\tInterpolateDiscrete,\r\n\tInterpolateLinear,\r\n\tLine,\r\n\tLineBasicMaterial,\r\n\tLineLoop,\r\n\tLineSegments,\r\n\tLinearFilter,\r\n\tLinearMipmapLinearFilter,\r\n\tLinearMipmapNearestFilter,\r\n\tLoader,\r\n\tLoaderUtils,\r\n\tMaterial,\r\n\tMathUtils,\r\n\tMatrix4,\r\n\tMesh,\r\n\tMeshBasicMaterial,\r\n\tMeshPhysicalMaterial,\r\n\tMeshStandardMaterial,\r\n\tMirroredRepeatWrapping,\r\n\tNearestFilter,\r\n\tNearestMipmapLinearFilter,\r\n\tNearestMipmapNearestFilter,\r\n\tNumberKeyframeTrack,\r\n\tObject3D,\r\n\tOrthographicCamera,\r\n\tPerspectiveCamera,\r\n\tPointLight,\r\n\tPoints,\r\n\tPointsMaterial,\r\n\tPropertyBinding,\r\n\tQuaternion,\r\n\tQuaternionKeyframeTrack,\r\n\tRGBFormat,\r\n\tRepeatWrapping,\r\n\tSkeleton,\r\n\tSkinnedMesh,\r\n\tSphere,\r\n\tSpotLight,\r\n\tTangentSpaceNormalMap,\r\n\tTexture,\r\n\tTextureLoader,\r\n\tTriangleFanDrawMode,\r\n\tTriangleStripDrawMode,\r\n\tVector2,\r\n\tVector3,\r\n\tVectorKeyframeTrack,\r\n\tsRGBEncoding\r\n} from 'three';\r\n\r\nclass GLTFLoader extends Loader {\r\n\r\n\tconstructor( manager ) {\r\n\r\n\t\tsuper( manager );\r\n\r\n\t\tthis.dracoLoader = null;\r\n\t\tthis.ktx2Loader = null;\r\n\t\tthis.meshoptDecoder = null;\r\n\r\n\t\tthis.pluginCallbacks = [];\r\n\r\n\t\tthis.register( function ( parser ) {\r\n\r\n\t\t\treturn new GLTFMaterialsClearcoatExtension( parser );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( parser ) {\r\n\r\n\t\t\treturn new GLTFTextureBasisUExtension( parser );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( parser ) {\r\n\r\n\t\t\treturn new GLTFTextureWebPExtension( parser );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( parser ) {\r\n\r\n\t\t\treturn new GLTFMaterialsSheenExtension( parser );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( parser ) {\r\n\r\n\t\t\treturn new GLTFMaterialsTransmissionExtension( parser );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( parser ) {\r\n\r\n\t\t\treturn new GLTFMaterialsVolumeExtension( parser );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( parser ) {\r\n\r\n\t\t\treturn new GLTFMaterialsIorExtension( parser );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( parser ) {\r\n\r\n\t\t\treturn new GLTFMaterialsSpecularExtension( parser );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( parser ) {\r\n\r\n\t\t\treturn new GLTFLightsExtension( parser );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( parser ) {\r\n\r\n\t\t\treturn new GLTFMeshoptCompression( parser );\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\tload( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tconst scope = this;\r\n\r\n\t\tlet resourcePath;\r\n\r\n\t\tif ( this.resourcePath !== '' ) {\r\n\r\n\t\t\tresourcePath = this.resourcePath;\r\n\r\n\t\t} else if ( this.path !== '' ) {\r\n\r\n\t\t\tresourcePath = this.path;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tresourcePath = LoaderUtils.extractUrlBase( url );\r\n\r\n\t\t}\r\n\r\n\t\t// Tells the LoadingManager to track an extra item, which resolves after\r\n\t\t// the model is fully loaded. This means the count of items loaded will\r\n\t\t// be incorrect, but ensures manager.onLoad() does not fire early.\r\n\t\tthis.manager.itemStart( url );\r\n\r\n\t\tconst _onError = function ( e ) {\r\n\r\n\t\t\tif ( onError ) {\r\n\r\n\t\t\t\tonError( e );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.error( e );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tscope.manager.itemError( url );\r\n\t\t\tscope.manager.itemEnd( url );\r\n\r\n\t\t};\r\n\r\n\t\tconst loader = new FileLoader( this.manager );\r\n\r\n\t\tloader.setPath( this.path );\r\n\t\tloader.setResponseType( 'arraybuffer' );\r\n\t\tloader.setRequestHeader( this.requestHeader );\r\n\t\tloader.setWithCredentials( this.withCredentials );\r\n\r\n\t\tloader.load( url, function ( data ) {\r\n\r\n\t\t\ttry {\r\n\r\n\t\t\t\tscope.parse( data, resourcePath, function ( gltf ) {\r\n\r\n\t\t\t\t\tonLoad( gltf );\r\n\r\n\t\t\t\t\tscope.manager.itemEnd( url );\r\n\r\n\t\t\t\t}, _onError );\r\n\r\n\t\t\t} catch ( e ) {\r\n\r\n\t\t\t\t_onError( e );\r\n\r\n\t\t\t}\r\n\r\n\t\t}, onProgress, _onError );\r\n\r\n\t}\r\n\r\n\tsetDRACOLoader( dracoLoader ) {\r\n\r\n\t\tthis.dracoLoader = dracoLoader;\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsetDDSLoader() {\r\n\r\n\t\tthrow new Error(\r\n\r\n\t\t\t'THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".'\r\n\r\n\t\t);\r\n\r\n\t}\r\n\r\n\tsetKTX2Loader( ktx2Loader ) {\r\n\r\n\t\tthis.ktx2Loader = ktx2Loader;\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsetMeshoptDecoder( meshoptDecoder ) {\r\n\r\n\t\tthis.meshoptDecoder = meshoptDecoder;\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tregister( callback ) {\r\n\r\n\t\tif ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {\r\n\r\n\t\t\tthis.pluginCallbacks.push( callback );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tunregister( callback ) {\r\n\r\n\t\tif ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {\r\n\r\n\t\t\tthis.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tparse( data, path, onLoad, onError ) {\r\n\r\n\t\tlet content;\r\n\t\tconst extensions = {};\r\n\t\tconst plugins = {};\r\n\r\n\t\tif ( typeof data === 'string' ) {\r\n\r\n\t\t\tcontent = data;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconst magic = LoaderUtils.decodeText( new Uint8Array( data, 0, 4 ) );\r\n\r\n\t\t\tif ( magic === BINARY_EXTENSION_HEADER_MAGIC ) {\r\n\r\n\t\t\t\ttry {\r\n\r\n\t\t\t\t\textensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );\r\n\r\n\t\t\t\t} catch ( error ) {\r\n\r\n\t\t\t\t\tif ( onError ) onError( error );\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcontent = extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tcontent = LoaderUtils.decodeText( new Uint8Array( data ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tconst json = JSON.parse( content );\r\n\r\n\t\tif ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) {\r\n\r\n\t\t\tif ( onError ) onError( new Error( 'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.' ) );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tconst parser = new GLTFParser( json, {\r\n\r\n\t\t\tpath: path || this.resourcePath || '',\r\n\t\t\tcrossOrigin: this.crossOrigin,\r\n\t\t\trequestHeader: this.requestHeader,\r\n\t\t\tmanager: this.manager,\r\n\t\t\tktx2Loader: this.ktx2Loader,\r\n\t\t\tmeshoptDecoder: this.meshoptDecoder\r\n\r\n\t\t} );\r\n\r\n\t\tparser.fileLoader.setRequestHeader( this.requestHeader );\r\n\r\n\t\tfor ( let i = 0; i < this.pluginCallbacks.length; i ++ ) {\r\n\r\n\t\t\tconst plugin = this.pluginCallbacks[ i ]( parser );\r\n\t\t\tplugins[ plugin.name ] = plugin;\r\n\r\n\t\t\t// Workaround to avoid determining as unknown extension\r\n\t\t\t// in addUnknownExtensionsToUserData().\r\n\t\t\t// Remove this workaround if we move all the existing\r\n\t\t\t// extension handlers to plugin system\r\n\t\t\textensions[ plugin.name ] = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( json.extensionsUsed ) {\r\n\r\n\t\t\tfor ( let i = 0; i < json.extensionsUsed.length; ++ i ) {\r\n\r\n\t\t\t\tconst extensionName = json.extensionsUsed[ i ];\r\n\t\t\t\tconst extensionsRequired = json.extensionsRequired || [];\r\n\r\n\t\t\t\tswitch ( extensionName ) {\r\n\r\n\t\t\t\t\tcase EXTENSIONS.KHR_MATERIALS_UNLIT:\r\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFMaterialsUnlitExtension();\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:\r\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFMaterialsPbrSpecularGlossinessExtension();\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\r\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFDracoMeshCompressionExtension( json, this.dracoLoader );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase EXTENSIONS.KHR_TEXTURE_TRANSFORM:\r\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFTextureTransformExtension();\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase EXTENSIONS.KHR_MESH_QUANTIZATION:\r\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFMeshQuantizationExtension();\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault:\r\n\r\n\t\t\t\t\t\tif ( extensionsRequired.indexOf( extensionName ) >= 0 && plugins[ extensionName ] === undefined ) {\r\n\r\n\t\t\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".' );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tparser.setExtensions( extensions );\r\n\t\tparser.setPlugins( plugins );\r\n\t\tparser.parse( onLoad, onError );\r\n\r\n\t}\r\n\r\n\tparseAsync( data, path ) {\r\n\r\n\t\tconst scope = this;\r\n\r\n\t\treturn new Promise( function ( resolve, reject ) {\r\n\r\n\t\t\tscope.parse( data, path, resolve, reject );\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n}\r\n\r\n/* GLTFREGISTRY */\r\n\r\nfunction GLTFRegistry() {\r\n\r\n\tlet objects = {};\r\n\r\n\treturn\t{\r\n\r\n\t\tget: function ( key ) {\r\n\r\n\t\t\treturn objects[ key ];\r\n\r\n\t\t},\r\n\r\n\t\tadd: function ( key, object ) {\r\n\r\n\t\t\tobjects[ key ] = object;\r\n\r\n\t\t},\r\n\r\n\t\tremove: function ( key ) {\r\n\r\n\t\t\tdelete objects[ key ];\r\n\r\n\t\t},\r\n\r\n\t\tremoveAll: function () {\r\n\r\n\t\t\tobjects = {};\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n}\r\n\r\n/*********************************/\r\n/********** EXTENSIONS ***********/\r\n/*********************************/\r\n\r\nconst EXTENSIONS = {\r\n\tKHR_BINARY_GLTF: 'KHR_binary_glTF',\r\n\tKHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\r\n\tKHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',\r\n\tKHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',\r\n\tKHR_MATERIALS_IOR: 'KHR_materials_ior',\r\n\tKHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',\r\n\tKHR_MATERIALS_SHEEN: 'KHR_materials_sheen',\r\n\tKHR_MATERIALS_SPECULAR: 'KHR_materials_specular',\r\n\tKHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',\r\n\tKHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\r\n\tKHR_MATERIALS_VOLUME: 'KHR_materials_volume',\r\n\tKHR_TEXTURE_BASISU: 'KHR_texture_basisu',\r\n\tKHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',\r\n\tKHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',\r\n\tEXT_TEXTURE_WEBP: 'EXT_texture_webp',\r\n\tEXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression'\r\n};\r\n\r\n/**\r\n * Punctual Lights Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\r\n */\r\nclass GLTFLightsExtension {\r\n\r\n\tconstructor( parser ) {\r\n\r\n\t\tthis.parser = parser;\r\n\t\tthis.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\r\n\r\n\t\t// Object3D instance caches\r\n\t\tthis.cache = { refs: {}, uses: {} };\r\n\r\n\t}\r\n\r\n\t_markDefs() {\r\n\r\n\t\tconst parser = this.parser;\r\n\t\tconst nodeDefs = this.parser.json.nodes || [];\r\n\r\n\t\tfor ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {\r\n\r\n\t\t\tconst nodeDef = nodeDefs[ nodeIndex ];\r\n\r\n\t\t\tif ( nodeDef.extensions\r\n\t\t\t\t\t&& nodeDef.extensions[ this.name ]\r\n\t\t\t\t\t&& nodeDef.extensions[ this.name ].light !== undefined ) {\r\n\r\n\t\t\t\tparser._addNodeRef( this.cache, nodeDef.extensions[ this.name ].light );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t_loadLight( lightIndex ) {\r\n\r\n\t\tconst parser = this.parser;\r\n\t\tconst cacheKey = 'light:' + lightIndex;\r\n\t\tlet dependency = parser.cache.get( cacheKey );\r\n\r\n\t\tif ( dependency ) return dependency;\r\n\r\n\t\tconst json = parser.json;\r\n\t\tconst extensions = ( json.extensions && json.extensions[ this.name ] ) || {};\r\n\t\tconst lightDefs = extensions.lights || [];\r\n\t\tconst lightDef = lightDefs[ lightIndex ];\r\n\t\tlet lightNode;\r\n\r\n\t\tconst color = new Color( 0xffffff );\r\n\r\n\t\tif ( lightDef.color !== undefined ) color.fromArray( lightDef.color );\r\n\r\n\t\tconst range = lightDef.range !== undefined ? lightDef.range : 0;\r\n\r\n\t\tswitch ( lightDef.type ) {\r\n\r\n\t\t\tcase 'directional':\r\n\t\t\t\tlightNode = new DirectionalLight( color );\r\n\t\t\t\tlightNode.target.position.set( 0, 0, - 1 );\r\n\t\t\t\tlightNode.add( lightNode.target );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'point':\r\n\t\t\t\tlightNode = new PointLight( color );\r\n\t\t\t\tlightNode.distance = range;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'spot':\r\n\t\t\t\tlightNode = new SpotLight( color );\r\n\t\t\t\tlightNode.distance = range;\r\n\t\t\t\t// Handle spotlight properties.\r\n\t\t\t\tlightDef.spot = lightDef.spot || {};\r\n\t\t\t\tlightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;\r\n\t\t\t\tlightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;\r\n\t\t\t\tlightNode.angle = lightDef.spot.outerConeAngle;\r\n\t\t\t\tlightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\r\n\t\t\t\tlightNode.target.position.set( 0, 0, - 1 );\r\n\t\t\t\tlightNode.add( lightNode.target );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Unexpected light type: ' + lightDef.type );\r\n\r\n\t\t}\r\n\r\n\t\t// Some lights (e.g. spot) default to a position other than the origin. Reset the position\r\n\t\t// here, because node-level parsing will only override position if explicitly specified.\r\n\t\tlightNode.position.set( 0, 0, 0 );\r\n\r\n\t\tlightNode.decay = 2;\r\n\r\n\t\tif ( lightDef.intensity !== undefined ) lightNode.intensity = lightDef.intensity;\r\n\r\n\t\tlightNode.name = parser.createUniqueName( lightDef.name || ( 'light_' + lightIndex ) );\r\n\r\n\t\tdependency = Promise.resolve( lightNode );\r\n\r\n\t\tparser.cache.add( cacheKey, dependency );\r\n\r\n\t\treturn dependency;\r\n\r\n\t}\r\n\r\n\tcreateNodeAttachment( nodeIndex ) {\r\n\r\n\t\tconst self = this;\r\n\t\tconst parser = this.parser;\r\n\t\tconst json = parser.json;\r\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\r\n\t\tconst lightDef = ( nodeDef.extensions && nodeDef.extensions[ this.name ] ) || {};\r\n\t\tconst lightIndex = lightDef.light;\r\n\r\n\t\tif ( lightIndex === undefined ) return null;\r\n\r\n\t\treturn this._loadLight( lightIndex ).then( function ( light ) {\r\n\r\n\t\t\treturn parser._getNodeRef( self.cache, lightIndex, light );\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Unlit Materials Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\r\n */\r\nclass GLTFMaterialsUnlitExtension {\r\n\r\n\tconstructor() {\r\n\r\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\r\n\r\n\t}\r\n\r\n\tgetMaterialType() {\r\n\r\n\t\treturn MeshBasicMaterial;\r\n\r\n\t}\r\n\r\n\textendParams( materialParams, materialDef, parser ) {\r\n\r\n\t\tconst pending = [];\r\n\r\n\t\tmaterialParams.color = new Color( 1.0, 1.0, 1.0 );\r\n\t\tmaterialParams.opacity = 1.0;\r\n\r\n\t\tconst metallicRoughness = materialDef.pbrMetallicRoughness;\r\n\r\n\t\tif ( metallicRoughness ) {\r\n\r\n\t\t\tif ( Array.isArray( metallicRoughness.baseColorFactor ) ) {\r\n\r\n\t\t\t\tconst array = metallicRoughness.baseColorFactor;\r\n\r\n\t\t\t\tmaterialParams.color.fromArray( array );\r\n\t\t\t\tmaterialParams.opacity = array[ 3 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( metallicRoughness.baseColorTexture !== undefined ) {\r\n\r\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.all( pending );\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Clearcoat Materials Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\r\n */\r\nclass GLTFMaterialsClearcoatExtension {\r\n\r\n\tconstructor( parser ) {\r\n\r\n\t\tthis.parser = parser;\r\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\r\n\r\n\t}\r\n\r\n\tgetMaterialType( materialIndex ) {\r\n\r\n\t\tconst parser = this.parser;\r\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\r\n\r\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\r\n\r\n\t\treturn MeshPhysicalMaterial;\r\n\r\n\t}\r\n\r\n\textendMaterialParams( materialIndex, materialParams ) {\r\n\r\n\t\tconst parser = this.parser;\r\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\r\n\r\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\r\n\r\n\t\t\treturn Promise.resolve();\r\n\r\n\t\t}\r\n\r\n\t\tconst pending = [];\r\n\r\n\t\tconst extension = materialDef.extensions[ this.name ];\r\n\r\n\t\tif ( extension.clearcoatFactor !== undefined ) {\r\n\r\n\t\t\tmaterialParams.clearcoat = extension.clearcoatFactor;\r\n\r\n\t\t}\r\n\r\n\t\tif ( extension.clearcoatTexture !== undefined ) {\r\n\r\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatMap', extension.clearcoatTexture ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( extension.clearcoatRoughnessFactor !== undefined ) {\r\n\r\n\t\t\tmaterialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\r\n\r\n\t\t}\r\n\r\n\t\tif ( extension.clearcoatRoughnessTexture !== undefined ) {\r\n\r\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( extension.clearcoatNormalTexture !== undefined ) {\r\n\r\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture ) );\r\n\r\n\t\t\tif ( extension.clearcoatNormalTexture.scale !== undefined ) {\r\n\r\n\t\t\t\tconst scale = extension.clearcoatNormalTexture.scale;\r\n\r\n\t\t\t\tmaterialParams.clearcoatNormalScale = new Vector2( scale, scale );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.all( pending );\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Sheen Materials Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen\r\n */\r\nclass GLTFMaterialsSheenExtension {\r\n\r\n\tconstructor( parser ) {\r\n\r\n\t\tthis.parser = parser;\r\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_SHEEN;\r\n\r\n\t}\r\n\r\n\tgetMaterialType( materialIndex ) {\r\n\r\n\t\tconst parser = this.parser;\r\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\r\n\r\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\r\n\r\n\t\treturn MeshPhysicalMaterial;\r\n\r\n\t}\r\n\r\n\textendMaterialParams( materialIndex, materialParams ) {\r\n\r\n\t\tconst parser = this.parser;\r\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\r\n\r\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\r\n\r\n\t\t\treturn Promise.resolve();\r\n\r\n\t\t}\r\n\r\n\t\tconst pending = [];\r\n\r\n\t\tmaterialParams.sheenColor = new Color( 0, 0, 0 );\r\n\t\tmaterialParams.sheenRoughness = 0;\r\n\t\tmaterialParams.sheen = 1;\r\n\r\n\t\tconst extension = materialDef.extensions[ this.name ];\r\n\r\n\t\tif ( extension.sheenColorFactor !== undefined ) {\r\n\r\n\t\t\tmaterialParams.sheenColor.fromArray( extension.sheenColorFactor );\r\n\r\n\t\t}\r\n\r\n\t\tif ( extension.sheenRoughnessFactor !== undefined ) {\r\n\r\n\t\t\tmaterialParams.sheenRoughness = extension.sheenRoughnessFactor;\r\n\r\n\t\t}\r\n\r\n\t\tif ( extension.sheenColorTexture !== undefined ) {\r\n\r\n\t\t\tpending.push( parser.assignTexture( materialParams, 'sheenColorMap', extension.sheenColorTexture ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( extension.sheenRoughnessTexture !== undefined ) {\r\n\r\n\t\t\tpending.push( parser.assignTexture( materialParams, 'sheenRoughnessMap', extension.sheenRoughnessTexture ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.all( pending );\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Transmission Materials Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\r\n * Draft: https://github.com/KhronosGroup/glTF/pull/1698\r\n */\r\nclass GLTFMaterialsTransmissionExtension {\r\n\r\n\tconstructor( parser ) {\r\n\r\n\t\tthis.parser = parser;\r\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;\r\n\r\n\t}\r\n\r\n\tgetMaterialType( materialIndex ) {\r\n\r\n\t\tconst parser = this.parser;\r\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\r\n\r\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\r\n\r\n\t\treturn MeshPhysicalMaterial;\r\n\r\n\t}\r\n\r\n\textendMaterialParams( materialIndex, materialParams ) {\r\n\r\n\t\tconst parser = this.parser;\r\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\r\n\r\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\r\n\r\n\t\t\treturn Promise.resolve();\r\n\r\n\t\t}\r\n\r\n\t\tconst pending = [];\r\n\r\n\t\tconst extension = materialDef.extensions[ this.name ];\r\n\r\n\t\tif ( extension.transmissionFactor !== undefined ) {\r\n\r\n\t\t\tmaterialParams.transmission = extension.transmissionFactor;\r\n\r\n\t\t}\r\n\r\n\t\tif ( extension.transmissionTexture !== undefined ) {\r\n\r\n\t\t\tpending.push( parser.assignTexture( materialParams, 'transmissionMap', extension.transmissionTexture ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.all( pending );\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Materials Volume Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\r\n */\r\nclass GLTFMaterialsVolumeExtension {\r\n\r\n\tconstructor( parser ) {\r\n\r\n\t\tthis.parser = parser;\r\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_VOLUME;\r\n\r\n\t}\r\n\r\n\tgetMaterialType( materialIndex ) {\r\n\r\n\t\tconst parser = this.parser;\r\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\r\n\r\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\r\n\r\n\t\treturn MeshPhysicalMaterial;\r\n\r\n\t}\r\n\r\n\textendMaterialParams( materialIndex, materialParams ) {\r\n\r\n\t\tconst parser = this.parser;\r\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\r\n\r\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\r\n\r\n\t\t\treturn Promise.resolve();\r\n\r\n\t\t}\r\n\r\n\t\tconst pending = [];\r\n\r\n\t\tconst extension = materialDef.extensions[ this.name ];\r\n\r\n\t\tmaterialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0;\r\n\r\n\t\tif ( extension.thicknessTexture !== undefined ) {\r\n\r\n\t\t\tpending.push( parser.assignTexture( materialParams, 'thicknessMap', extension.thicknessTexture ) );\r\n\r\n\t\t}\r\n\r\n\t\tmaterialParams.attenuationDistance = extension.attenuationDistance || 0;\r\n\r\n\t\tconst colorArray = extension.attenuationColor || [ 1, 1, 1 ];\r\n\t\tmaterialParams.attenuationColor = new Color( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ] );\r\n\r\n\t\treturn Promise.all( pending );\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Materials ior Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior\r\n */\r\nclass GLTFMaterialsIorExtension {\r\n\r\n\tconstructor( parser ) {\r\n\r\n\t\tthis.parser = parser;\r\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_IOR;\r\n\r\n\t}\r\n\r\n\tgetMaterialType( materialIndex ) {\r\n\r\n\t\tconst parser = this.parser;\r\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\r\n\r\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\r\n\r\n\t\treturn MeshPhysicalMaterial;\r\n\r\n\t}\r\n\r\n\textendMaterialParams( materialIndex, materialParams ) {\r\n\r\n\t\tconst parser = this.parser;\r\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\r\n\r\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\r\n\r\n\t\t\treturn Promise.resolve();\r\n\r\n\t\t}\r\n\r\n\t\tconst extension = materialDef.extensions[ this.name ];\r\n\r\n\t\tmaterialParams.ior = extension.ior !== undefined ? extension.ior : 1.5;\r\n\r\n\t\treturn Promise.resolve();\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Materials specular Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular\r\n */\r\nclass GLTFMaterialsSpecularExtension {\r\n\r\n\tconstructor( parser ) {\r\n\r\n\t\tthis.parser = parser;\r\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;\r\n\r\n\t}\r\n\r\n\tgetMaterialType( materialIndex ) {\r\n\r\n\t\tconst parser = this.parser;\r\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\r\n\r\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\r\n\r\n\t\treturn MeshPhysicalMaterial;\r\n\r\n\t}\r\n\r\n\textendMaterialParams( materialIndex, materialParams ) {\r\n\r\n\t\tconst parser = this.parser;\r\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\r\n\r\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\r\n\r\n\t\t\treturn Promise.resolve();\r\n\r\n\t\t}\r\n\r\n\t\tconst pending = [];\r\n\r\n\t\tconst extension = materialDef.extensions[ this.name ];\r\n\r\n\t\tmaterialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0;\r\n\r\n\t\tif ( extension.specularTexture !== undefined ) {\r\n\r\n\t\t\tpending.push( parser.assignTexture( materialParams, 'specularIntensityMap', extension.specularTexture ) );\r\n\r\n\t\t}\r\n\r\n\t\tconst colorArray = extension.specularColorFactor || [ 1, 1, 1 ];\r\n\t\tmaterialParams.specularColor = new Color( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ] );\r\n\r\n\t\tif ( extension.specularColorTexture !== undefined ) {\r\n\r\n\t\t\tpending.push( parser.assignTexture( materialParams, 'specularColorMap', extension.specularColorTexture ).then( function ( texture ) {\r\n\r\n\t\t\t\ttexture.encoding = sRGBEncoding;\r\n\r\n\t\t\t} ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.all( pending );\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * BasisU Texture Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu\r\n */\r\nclass GLTFTextureBasisUExtension {\r\n\r\n\tconstructor( parser ) {\r\n\r\n\t\tthis.parser = parser;\r\n\t\tthis.name = EXTENSIONS.KHR_TEXTURE_BASISU;\r\n\r\n\t}\r\n\r\n\tloadTexture( textureIndex ) {\r\n\r\n\t\tconst parser = this.parser;\r\n\t\tconst json = parser.json;\r\n\r\n\t\tconst textureDef = json.textures[ textureIndex ];\r\n\r\n\t\tif ( ! textureDef.extensions || ! textureDef.extensions[ this.name ] ) {\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tconst extension = textureDef.extensions[ this.name ];\r\n\t\tconst source = json.images[ extension.source ];\r\n\t\tconst loader = parser.options.ktx2Loader;\r\n\r\n\t\tif ( ! loader ) {\r\n\r\n\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {\r\n\r\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures' );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// Assumes that the extension is optional and that a fallback texture is present\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn parser.loadTextureImage( textureIndex, source, loader );\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * WebP Texture Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp\r\n */\r\nclass GLTFTextureWebPExtension {\r\n\r\n\tconstructor( parser ) {\r\n\r\n\t\tthis.parser = parser;\r\n\t\tthis.name = EXTENSIONS.EXT_TEXTURE_WEBP;\r\n\t\tthis.isSupported = null;\r\n\r\n\t}\r\n\r\n\tloadTexture( textureIndex ) {\r\n\r\n\t\tconst name = this.name;\r\n\t\tconst parser = this.parser;\r\n\t\tconst json = parser.json;\r\n\r\n\t\tconst textureDef = json.textures[ textureIndex ];\r\n\r\n\t\tif ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tconst extension = textureDef.extensions[ name ];\r\n\t\tconst source = json.images[ extension.source ];\r\n\r\n\t\tlet loader = parser.textureLoader;\r\n\t\tif ( source.uri ) {\r\n\r\n\t\t\tconst handler = parser.options.manager.getHandler( source.uri );\r\n\t\t\tif ( handler !== null ) loader = handler;\r\n\r\n\t\t}\r\n\r\n\t\treturn this.detectSupport().then( function ( isSupported ) {\r\n\r\n\t\t\tif ( isSupported ) return parser.loadTextureImage( textureIndex, source, loader );\r\n\r\n\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) {\r\n\r\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: WebP required by asset but unsupported.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Fall back to PNG or JPEG.\r\n\t\t\treturn parser.loadTexture( textureIndex );\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\tdetectSupport() {\r\n\r\n\t\tif ( ! this.isSupported ) {\r\n\r\n\t\t\tthis.isSupported = new Promise( function ( resolve ) {\r\n\r\n\t\t\t\tconst image = new Image();\r\n\r\n\t\t\t\t// Lossy test image. Support for lossy images doesn't guarantee support for all\r\n\t\t\t\t// WebP images, unfortunately.\r\n\t\t\t\timage.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';\r\n\r\n\t\t\t\timage.onload = image.onerror = function () {\r\n\r\n\t\t\t\t\tresolve( image.height === 1 );\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t\treturn this.isSupported;\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * meshopt BufferView Compression Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression\r\n */\r\nclass GLTFMeshoptCompression {\r\n\r\n\tconstructor( parser ) {\r\n\r\n\t\tthis.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;\r\n\t\tthis.parser = parser;\r\n\r\n\t}\r\n\r\n\tloadBufferView( index ) {\r\n\r\n\t\tconst json = this.parser.json;\r\n\t\tconst bufferView = json.bufferViews[ index ];\r\n\r\n\t\tif ( bufferView.extensions && bufferView.extensions[ this.name ] ) {\r\n\r\n\t\t\tconst extensionDef = bufferView.extensions[ this.name ];\r\n\r\n\t\t\tconst buffer = this.parser.getDependency( 'buffer', extensionDef.buffer );\r\n\t\t\tconst decoder = this.parser.options.meshoptDecoder;\r\n\r\n\t\t\tif ( ! decoder || ! decoder.supported ) {\r\n\r\n\t\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {\r\n\r\n\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files' );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// Assumes that the extension is optional and that fallback buffer data is present\r\n\t\t\t\t\treturn null;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn Promise.all( [ buffer, decoder.ready ] ).then( function ( res ) {\r\n\r\n\t\t\t\tconst byteOffset = extensionDef.byteOffset || 0;\r\n\t\t\t\tconst byteLength = extensionDef.byteLength || 0;\r\n\r\n\t\t\t\tconst count = extensionDef.count;\r\n\t\t\t\tconst stride = extensionDef.byteStride;\r\n\r\n\t\t\t\tconst result = new ArrayBuffer( count * stride );\r\n\t\t\t\tconst source = new Uint8Array( res[ 0 ], byteOffset, byteLength );\r\n\r\n\t\t\t\tdecoder.decodeGltfBuffer( new Uint8Array( result ), count, stride, source, extensionDef.mode, extensionDef.filter );\r\n\t\t\t\treturn result;\r\n\r\n\t\t\t} );\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\n/* BINARY EXTENSION */\r\nconst BINARY_EXTENSION_HEADER_MAGIC = 'glTF';\r\nconst BINARY_EXTENSION_HEADER_LENGTH = 12;\r\nconst BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };\r\n\r\nclass GLTFBinaryExtension {\r\n\r\n\tconstructor( data ) {\r\n\r\n\t\tthis.name = EXTENSIONS.KHR_BINARY_GLTF;\r\n\t\tthis.content = null;\r\n\t\tthis.body = null;\r\n\r\n\t\tconst headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );\r\n\r\n\t\tthis.header = {\r\n\t\t\tmagic: LoaderUtils.decodeText( new Uint8Array( data.slice( 0, 4 ) ) ),\r\n\t\t\tversion: headerView.getUint32( 4, true ),\r\n\t\t\tlength: headerView.getUint32( 8, true )\r\n\t\t};\r\n\r\n\t\tif ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {\r\n\r\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Unsupported glTF-Binary header.' );\r\n\r\n\t\t} else if ( this.header.version < 2.0 ) {\r\n\r\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Legacy binary file detected.' );\r\n\r\n\t\t}\r\n\r\n\t\tconst chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;\r\n\t\tconst chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH );\r\n\t\tlet chunkIndex = 0;\r\n\r\n\t\twhile ( chunkIndex < chunkContentsLength ) {\r\n\r\n\t\t\tconst chunkLength = chunkView.getUint32( chunkIndex, true );\r\n\t\t\tchunkIndex += 4;\r\n\r\n\t\t\tconst chunkType = chunkView.getUint32( chunkIndex, true );\r\n\t\t\tchunkIndex += 4;\r\n\r\n\t\t\tif ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {\r\n\r\n\t\t\t\tconst contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength );\r\n\t\t\t\tthis.content = LoaderUtils.decodeText( contentArray );\r\n\r\n\t\t\t} else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {\r\n\r\n\t\t\t\tconst byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\r\n\t\t\t\tthis.body = data.slice( byteOffset, byteOffset + chunkLength );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Clients must ignore chunks with unknown types.\r\n\r\n\t\t\tchunkIndex += chunkLength;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.content === null ) {\r\n\r\n\t\t\tthrow new Error( 'THREE.GLTFLoader: JSON content not found.' );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * DRACO Mesh Compression Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\r\n */\r\nclass GLTFDracoMeshCompressionExtension {\r\n\r\n\tconstructor( json, dracoLoader ) {\r\n\r\n\t\tif ( ! dracoLoader ) {\r\n\r\n\t\t\tthrow new Error( 'THREE.GLTFLoader: No DRACOLoader instance provided.' );\r\n\r\n\t\t}\r\n\r\n\t\tthis.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\r\n\t\tthis.json = json;\r\n\t\tthis.dracoLoader = dracoLoader;\r\n\t\tthis.dracoLoader.preload();\r\n\r\n\t}\r\n\r\n\tdecodePrimitive( primitive, parser ) {\r\n\r\n\t\tconst json = this.json;\r\n\t\tconst dracoLoader = this.dracoLoader;\r\n\t\tconst bufferViewIndex = primitive.extensions[ this.name ].bufferView;\r\n\t\tconst gltfAttributeMap = primitive.extensions[ this.name ].attributes;\r\n\t\tconst threeAttributeMap = {};\r\n\t\tconst attributeNormalizedMap = {};\r\n\t\tconst attributeTypeMap = {};\r\n\r\n\t\tfor ( const attributeName in gltfAttributeMap ) {\r\n\r\n\t\t\tconst threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();\r\n\r\n\t\t\tthreeAttributeMap[ threeAttributeName ] = gltfAttributeMap[ attributeName ];\r\n\r\n\t\t}\r\n\r\n\t\tfor ( const attributeName in primitive.attributes ) {\r\n\r\n\t\t\tconst threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();\r\n\r\n\t\t\tif ( gltfAttributeMap[ attributeName ] !== undefined ) {\r\n\r\n\t\t\t\tconst accessorDef = json.accessors[ primitive.attributes[ attributeName ] ];\r\n\t\t\t\tconst componentType = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\r\n\r\n\t\t\t\tattributeTypeMap[ threeAttributeName ] = componentType;\r\n\t\t\t\tattributeNormalizedMap[ threeAttributeName ] = accessorDef.normalized === true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn parser.getDependency( 'bufferView', bufferViewIndex ).then( function ( bufferView ) {\r\n\r\n\t\t\treturn new Promise( function ( resolve ) {\r\n\r\n\t\t\t\tdracoLoader.decodeDracoFile( bufferView, function ( geometry ) {\r\n\r\n\t\t\t\t\tfor ( const attributeName in geometry.attributes ) {\r\n\r\n\t\t\t\t\t\tconst attribute = geometry.attributes[ attributeName ];\r\n\t\t\t\t\t\tconst normalized = attributeNormalizedMap[ attributeName ];\r\n\r\n\t\t\t\t\t\tif ( normalized !== undefined ) attribute.normalized = normalized;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tresolve( geometry );\r\n\r\n\t\t\t\t}, threeAttributeMap, attributeTypeMap );\r\n\r\n\t\t\t} );\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Texture Transform Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform\r\n */\r\nclass GLTFTextureTransformExtension {\r\n\r\n\tconstructor() {\r\n\r\n\t\tthis.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\r\n\r\n\t}\r\n\r\n\textendTexture( texture, transform ) {\r\n\r\n\t\tif ( transform.texCoord !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Custom UV sets in \"' + this.name + '\" extension not yet supported.' );\r\n\r\n\t\t}\r\n\r\n\t\tif ( transform.offset === undefined && transform.rotation === undefined && transform.scale === undefined ) {\r\n\r\n\t\t\t// See https://github.com/mrdoob/three.js/issues/21819.\r\n\t\t\treturn texture;\r\n\r\n\t\t}\r\n\r\n\t\ttexture = texture.clone();\r\n\r\n\t\tif ( transform.offset !== undefined ) {\r\n\r\n\t\t\ttexture.offset.fromArray( transform.offset );\r\n\r\n\t\t}\r\n\r\n\t\tif ( transform.rotation !== undefined ) {\r\n\r\n\t\t\ttexture.rotation = transform.rotation;\r\n\r\n\t\t}\r\n\r\n\t\tif ( transform.scale !== undefined ) {\r\n\r\n\t\t\ttexture.repeat.fromArray( transform.scale );\r\n\r\n\t\t}\r\n\r\n\t\ttexture.needsUpdate = true;\r\n\r\n\t\treturn texture;\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Specular-Glossiness Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Archived/KHR_materials_pbrSpecularGlossiness\r\n */\r\n\r\n/**\r\n * A sub class of StandardMaterial with some of the functionality\r\n * changed via the `onBeforeCompile` callback\r\n * @pailhead\r\n */\r\nclass GLTFMeshStandardSGMaterial extends MeshStandardMaterial {\r\n\r\n\tconstructor( params ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.isGLTFSpecularGlossinessMaterial = true;\r\n\r\n\t\t//various chunks that need replacing\r\n\t\tconst specularMapParsFragmentChunk = [\r\n\t\t\t'#ifdef USE_SPECULARMAP',\r\n\t\t\t'\tuniform sampler2D specularMap;',\r\n\t\t\t'#endif'\r\n\t\t].join( '\\n' );\r\n\r\n\t\tconst glossinessMapParsFragmentChunk = [\r\n\t\t\t'#ifdef USE_GLOSSINESSMAP',\r\n\t\t\t'\tuniform sampler2D glossinessMap;',\r\n\t\t\t'#endif'\r\n\t\t].join( '\\n' );\r\n\r\n\t\tconst specularMapFragmentChunk = [\r\n\t\t\t'vec3 specularFactor = specular;',\r\n\t\t\t'#ifdef USE_SPECULARMAP',\r\n\t\t\t'\tvec4 texelSpecular = texture2D( specularMap, vUv );',\r\n\t\t\t'\ttexelSpecular = sRGBToLinear( texelSpecular );',\r\n\t\t\t'\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture',\r\n\t\t\t'\tspecularFactor *= texelSpecular.rgb;',\r\n\t\t\t'#endif'\r\n\t\t].join( '\\n' );\r\n\r\n\t\tconst glossinessMapFragmentChunk = [\r\n\t\t\t'float glossinessFactor = glossiness;',\r\n\t\t\t'#ifdef USE_GLOSSINESSMAP',\r\n\t\t\t'\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );',\r\n\t\t\t'\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture',\r\n\t\t\t'\tglossinessFactor *= texelGlossiness.a;',\r\n\t\t\t'#endif'\r\n\t\t].join( '\\n' );\r\n\r\n\t\tconst lightPhysicalFragmentChunk = [\r\n\t\t\t'PhysicalMaterial material;',\r\n\t\t\t'material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );',\r\n\t\t\t'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );',\r\n\t\t\t'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );',\r\n\t\t\t'material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.',\r\n\t\t\t'material.roughness += geometryRoughness;',\r\n\t\t\t'material.roughness = min( material.roughness, 1.0 );',\r\n\t\t\t'material.specularColor = specularFactor;',\r\n\t\t].join( '\\n' );\r\n\r\n\t\tconst uniforms = {\r\n\t\t\tspecular: { value: new Color().setHex( 0xffffff ) },\r\n\t\t\tglossiness: { value: 1 },\r\n\t\t\tspecularMap: { value: null },\r\n\t\t\tglossinessMap: { value: null }\r\n\t\t};\r\n\r\n\t\tthis._extraUniforms = uniforms;\r\n\r\n\t\tthis.onBeforeCompile = function ( shader ) {\r\n\r\n\t\t\tfor ( const uniformName in uniforms ) {\r\n\r\n\t\t\t\tshader.uniforms[ uniformName ] = uniforms[ uniformName ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tshader.fragmentShader = shader.fragmentShader\r\n\t\t\t\t.replace( 'uniform float roughness;', 'uniform vec3 specular;' )\r\n\t\t\t\t.replace( 'uniform float metalness;', 'uniform float glossiness;' )\r\n\t\t\t\t.replace( '#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk )\r\n\t\t\t\t.replace( '#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk )\r\n\t\t\t\t.replace( '#include <roughnessmap_fragment>', specularMapFragmentChunk )\r\n\t\t\t\t.replace( '#include <metalnessmap_fragment>', glossinessMapFragmentChunk )\r\n\t\t\t\t.replace( '#include <lights_physical_fragment>', lightPhysicalFragmentChunk );\r\n\r\n\t\t};\r\n\r\n\t\tObject.defineProperties( this, {\r\n\r\n\t\t\tspecular: {\r\n\t\t\t\tget: function () {\r\n\r\n\t\t\t\t\treturn uniforms.specular.value;\r\n\r\n\t\t\t\t},\r\n\t\t\t\tset: function ( v ) {\r\n\r\n\t\t\t\t\tuniforms.specular.value = v;\r\n\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\tspecularMap: {\r\n\t\t\t\tget: function () {\r\n\r\n\t\t\t\t\treturn uniforms.specularMap.value;\r\n\r\n\t\t\t\t},\r\n\t\t\t\tset: function ( v ) {\r\n\r\n\t\t\t\t\tuniforms.specularMap.value = v;\r\n\r\n\t\t\t\t\tif ( v ) {\r\n\r\n\t\t\t\t\t\tthis.defines.USE_SPECULARMAP = ''; // USE_UV is set by the renderer for specular maps\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tdelete this.defines.USE_SPECULARMAP;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\tglossiness: {\r\n\t\t\t\tget: function () {\r\n\r\n\t\t\t\t\treturn uniforms.glossiness.value;\r\n\r\n\t\t\t\t},\r\n\t\t\t\tset: function ( v ) {\r\n\r\n\t\t\t\t\tuniforms.glossiness.value = v;\r\n\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\tglossinessMap: {\r\n\t\t\t\tget: function () {\r\n\r\n\t\t\t\t\treturn uniforms.glossinessMap.value;\r\n\r\n\t\t\t\t},\r\n\t\t\t\tset: function ( v ) {\r\n\r\n\t\t\t\t\tuniforms.glossinessMap.value = v;\r\n\r\n\t\t\t\t\tif ( v ) {\r\n\r\n\t\t\t\t\t\tthis.defines.USE_GLOSSINESSMAP = '';\r\n\t\t\t\t\t\tthis.defines.USE_UV = '';\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tdelete this.defines.USE_GLOSSINESSMAP;\r\n\t\t\t\t\t\tdelete this.defines.USE_UV;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\tdelete this.metalness;\r\n\t\tdelete this.roughness;\r\n\t\tdelete this.metalnessMap;\r\n\t\tdelete this.roughnessMap;\r\n\r\n\t\tthis.setValues( params );\r\n\r\n\t}\r\n\r\n\tcopy( source ) {\r\n\r\n\t\tsuper.copy( source );\r\n\r\n\t\tthis.specularMap = source.specularMap;\r\n\t\tthis.specular.copy( source.specular );\r\n\t\tthis.glossinessMap = source.glossinessMap;\r\n\t\tthis.glossiness = source.glossiness;\r\n\t\tdelete this.metalness;\r\n\t\tdelete this.roughness;\r\n\t\tdelete this.metalnessMap;\r\n\t\tdelete this.roughnessMap;\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\nclass GLTFMaterialsPbrSpecularGlossinessExtension {\r\n\r\n\tconstructor() {\r\n\r\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;\r\n\r\n\t\tthis.specularGlossinessParams = [\r\n\t\t\t'color',\r\n\t\t\t'map',\r\n\t\t\t'lightMap',\r\n\t\t\t'lightMapIntensity',\r\n\t\t\t'aoMap',\r\n\t\t\t'aoMapIntensity',\r\n\t\t\t'emissive',\r\n\t\t\t'emissiveIntensity',\r\n\t\t\t'emissiveMap',\r\n\t\t\t'bumpMap',\r\n\t\t\t'bumpScale',\r\n\t\t\t'normalMap',\r\n\t\t\t'normalMapType',\r\n\t\t\t'displacementMap',\r\n\t\t\t'displacementScale',\r\n\t\t\t'displacementBias',\r\n\t\t\t'specularMap',\r\n\t\t\t'specular',\r\n\t\t\t'glossinessMap',\r\n\t\t\t'glossiness',\r\n\t\t\t'alphaMap',\r\n\t\t\t'envMap',\r\n\t\t\t'envMapIntensity',\r\n\t\t\t'refractionRatio',\r\n\t\t];\r\n\r\n\t}\r\n\r\n\tgetMaterialType() {\r\n\r\n\t\treturn GLTFMeshStandardSGMaterial;\r\n\r\n\t}\r\n\r\n\textendParams( materialParams, materialDef, parser ) {\r\n\r\n\t\tconst pbrSpecularGlossiness = materialDef.extensions[ this.name ];\r\n\r\n\t\tmaterialParams.color = new Color( 1.0, 1.0, 1.0 );\r\n\t\tmaterialParams.opacity = 1.0;\r\n\r\n\t\tconst pending = [];\r\n\r\n\t\tif ( Array.isArray( pbrSpecularGlossiness.diffuseFactor ) ) {\r\n\r\n\t\t\tconst array = pbrSpecularGlossiness.diffuseFactor;\r\n\r\n\t\t\tmaterialParams.color.fromArray( array );\r\n\t\t\tmaterialParams.opacity = array[ 3 ];\r\n\r\n\t\t}\r\n\r\n\t\tif ( pbrSpecularGlossiness.diffuseTexture !== undefined ) {\r\n\r\n\t\t\tpending.push( parser.assignTexture( materialParams, 'map', pbrSpecularGlossiness.diffuseTexture ) );\r\n\r\n\t\t}\r\n\r\n\t\tmaterialParams.emissive = new Color( 0.0, 0.0, 0.0 );\r\n\t\tmaterialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;\r\n\t\tmaterialParams.specular = new Color( 1.0, 1.0, 1.0 );\r\n\r\n\t\tif ( Array.isArray( pbrSpecularGlossiness.specularFactor ) ) {\r\n\r\n\t\t\tmaterialParams.specular.fromArray( pbrSpecularGlossiness.specularFactor );\r\n\r\n\t\t}\r\n\r\n\t\tif ( pbrSpecularGlossiness.specularGlossinessTexture !== undefined ) {\r\n\r\n\t\t\tconst specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;\r\n\t\t\tpending.push( parser.assignTexture( materialParams, 'glossinessMap', specGlossMapDef ) );\r\n\t\t\tpending.push( parser.assignTexture( materialParams, 'specularMap', specGlossMapDef ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.all( pending );\r\n\r\n\t}\r\n\r\n\tcreateMaterial( materialParams ) {\r\n\r\n\t\tconst material = new GLTFMeshStandardSGMaterial( materialParams );\r\n\t\tmaterial.fog = true;\r\n\r\n\t\tmaterial.color = materialParams.color;\r\n\r\n\t\tmaterial.map = materialParams.map === undefined ? null : materialParams.map;\r\n\r\n\t\tmaterial.lightMap = null;\r\n\t\tmaterial.lightMapIntensity = 1.0;\r\n\r\n\t\tmaterial.aoMap = materialParams.aoMap === undefined ? null : materialParams.aoMap;\r\n\t\tmaterial.aoMapIntensity = 1.0;\r\n\r\n\t\tmaterial.emissive = materialParams.emissive;\r\n\t\tmaterial.emissiveIntensity = 1.0;\r\n\t\tmaterial.emissiveMap = materialParams.emissiveMap === undefined ? null : materialParams.emissiveMap;\r\n\r\n\t\tmaterial.bumpMap = materialParams.bumpMap === undefined ? null : materialParams.bumpMap;\r\n\t\tmaterial.bumpScale = 1;\r\n\r\n\t\tmaterial.normalMap = materialParams.normalMap === undefined ? null : materialParams.normalMap;\r\n\t\tmaterial.normalMapType = TangentSpaceNormalMap;\r\n\r\n\t\tif ( materialParams.normalScale ) material.normalScale = materialParams.normalScale;\r\n\r\n\t\tmaterial.displacementMap = null;\r\n\t\tmaterial.displacementScale = 1;\r\n\t\tmaterial.displacementBias = 0;\r\n\r\n\t\tmaterial.specularMap = materialParams.specularMap === undefined ? null : materialParams.specularMap;\r\n\t\tmaterial.specular = materialParams.specular;\r\n\r\n\t\tmaterial.glossinessMap = materialParams.glossinessMap === undefined ? null : materialParams.glossinessMap;\r\n\t\tmaterial.glossiness = materialParams.glossiness;\r\n\r\n\t\tmaterial.alphaMap = null;\r\n\r\n\t\tmaterial.envMap = materialParams.envMap === undefined ? null : materialParams.envMap;\r\n\t\tmaterial.envMapIntensity = 1.0;\r\n\r\n\t\tmaterial.refractionRatio = 0.98;\r\n\r\n\t\treturn material;\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Mesh Quantization Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization\r\n */\r\nclass GLTFMeshQuantizationExtension {\r\n\r\n\tconstructor() {\r\n\r\n\t\tthis.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\r\n\r\n\t}\r\n\r\n}\r\n\r\n/*********************************/\r\n/********** INTERPOLATION ********/\r\n/*********************************/\r\n\r\n// Spline Interpolation\r\n// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\r\nclass GLTFCubicSplineInterpolant extends Interpolant {\r\n\r\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\r\n\r\n\t\tsuper( parameterPositions, sampleValues, sampleSize, resultBuffer );\r\n\r\n\t}\r\n\r\n\tcopySampleValue_( index ) {\r\n\r\n\t\t// Copies a sample value to the result buffer. See description of glTF\r\n\t\t// CUBICSPLINE values layout in interpolate_() function below.\r\n\r\n\t\tconst result = this.resultBuffer,\r\n\t\t\tvalues = this.sampleValues,\r\n\t\t\tvalueSize = this.valueSize,\r\n\t\t\toffset = index * valueSize * 3 + valueSize;\r\n\r\n\t\tfor ( let i = 0; i !== valueSize; i ++ ) {\r\n\r\n\t\t\tresult[ i ] = values[ offset + i ];\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n}\r\n\r\nGLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\r\n\r\nGLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\r\n\r\nGLTFCubicSplineInterpolant.prototype.interpolate_ = function ( i1, t0, t, t1 ) {\r\n\r\n\tconst result = this.resultBuffer;\r\n\tconst values = this.sampleValues;\r\n\tconst stride = this.valueSize;\r\n\r\n\tconst stride2 = stride * 2;\r\n\tconst stride3 = stride * 3;\r\n\r\n\tconst td = t1 - t0;\r\n\r\n\tconst p = ( t - t0 ) / td;\r\n\tconst pp = p * p;\r\n\tconst ppp = pp * p;\r\n\r\n\tconst offset1 = i1 * stride3;\r\n\tconst offset0 = offset1 - stride3;\r\n\r\n\tconst s2 = - 2 * ppp + 3 * pp;\r\n\tconst s3 = ppp - pp;\r\n\tconst s0 = 1 - s2;\r\n\tconst s1 = s3 - pp + p;\r\n\r\n\t// Layout of keyframe output values for CUBICSPLINE animations:\r\n\t//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\r\n\tfor ( let i = 0; i !== stride; i ++ ) {\r\n\r\n\t\tconst p0 = values[ offset0 + i + stride ]; // splineVertex_k\r\n\t\tconst m0 = values[ offset0 + i + stride2 ] * td; // outTangent_k * (t_k+1 - t_k)\r\n\t\tconst p1 = values[ offset1 + i + stride ]; // splineVertex_k+1\r\n\t\tconst m1 = values[ offset1 + i ] * td; // inTangent_k+1 * (t_k+1 - t_k)\r\n\r\n\t\tresult[ i ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\r\n\r\n\t}\r\n\r\n\treturn result;\r\n\r\n};\r\n\r\nconst _q = new Quaternion();\r\n\r\nclass GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {\r\n\r\n\tinterpolate_( i1, t0, t, t1 ) {\r\n\r\n\t\tconst result = super.interpolate_( i1, t0, t, t1 );\r\n\r\n\t\t_q.fromArray( result ).normalize().toArray( result );\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n/*********************************/\r\n/********** INTERNALS ************/\r\n/*********************************/\r\n\r\n/* CONSTANTS */\r\n\r\nconst WEBGL_CONSTANTS = {\r\n\tFLOAT: 5126,\r\n\t//FLOAT_MAT2: 35674,\r\n\tFLOAT_MAT3: 35675,\r\n\tFLOAT_MAT4: 35676,\r\n\tFLOAT_VEC2: 35664,\r\n\tFLOAT_VEC3: 35665,\r\n\tFLOAT_VEC4: 35666,\r\n\tLINEAR: 9729,\r\n\tREPEAT: 10497,\r\n\tSAMPLER_2D: 35678,\r\n\tPOINTS: 0,\r\n\tLINES: 1,\r\n\tLINE_LOOP: 2,\r\n\tLINE_STRIP: 3,\r\n\tTRIANGLES: 4,\r\n\tTRIANGLE_STRIP: 5,\r\n\tTRIANGLE_FAN: 6,\r\n\tUNSIGNED_BYTE: 5121,\r\n\tUNSIGNED_SHORT: 5123\r\n};\r\n\r\nconst WEBGL_COMPONENT_TYPES = {\r\n\t5120: Int8Array,\r\n\t5121: Uint8Array,\r\n\t5122: Int16Array,\r\n\t5123: Uint16Array,\r\n\t5125: Uint32Array,\r\n\t5126: Float32Array\r\n};\r\n\r\nconst WEBGL_FILTERS = {\r\n\t9728: NearestFilter,\r\n\t9729: LinearFilter,\r\n\t9984: NearestMipmapNearestFilter,\r\n\t9985: LinearMipmapNearestFilter,\r\n\t9986: NearestMipmapLinearFilter,\r\n\t9987: LinearMipmapLinearFilter\r\n};\r\n\r\nconst WEBGL_WRAPPINGS = {\r\n\t33071: ClampToEdgeWrapping,\r\n\t33648: MirroredRepeatWrapping,\r\n\t10497: RepeatWrapping\r\n};\r\n\r\nconst WEBGL_TYPE_SIZES = {\r\n\t'SCALAR': 1,\r\n\t'VEC2': 2,\r\n\t'VEC3': 3,\r\n\t'VEC4': 4,\r\n\t'MAT2': 4,\r\n\t'MAT3': 9,\r\n\t'MAT4': 16\r\n};\r\n\r\nconst ATTRIBUTES = {\r\n\tPOSITION: 'position',\r\n\tNORMAL: 'normal',\r\n\tTANGENT: 'tangent',\r\n\tTEXCOORD_0: 'uv',\r\n\tTEXCOORD_1: 'uv2',\r\n\tCOLOR_0: 'color',\r\n\tWEIGHTS_0: 'skinWeight',\r\n\tJOINTS_0: 'skinIndex',\r\n};\r\n\r\nconst PATH_PROPERTIES = {\r\n\tscale: 'scale',\r\n\ttranslation: 'position',\r\n\trotation: 'quaternion',\r\n\tweights: 'morphTargetInfluences'\r\n};\r\n\r\nconst INTERPOLATION = {\r\n\tCUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\r\n\t\t                        // keyframe track will be initialized with a default interpolation type, then modified.\r\n\tLINEAR: InterpolateLinear,\r\n\tSTEP: InterpolateDiscrete\r\n};\r\n\r\nconst ALPHA_MODES = {\r\n\tOPAQUE: 'OPAQUE',\r\n\tMASK: 'MASK',\r\n\tBLEND: 'BLEND'\r\n};\r\n\r\n/**\r\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\r\n */\r\nfunction createDefaultMaterial( cache ) {\r\n\r\n\tif ( cache[ 'DefaultMaterial' ] === undefined ) {\r\n\r\n\t\tcache[ 'DefaultMaterial' ] = new MeshStandardMaterial( {\r\n\t\t\tcolor: 0xFFFFFF,\r\n\t\t\temissive: 0x000000,\r\n\t\t\tmetalness: 1,\r\n\t\t\troughness: 1,\r\n\t\t\ttransparent: false,\r\n\t\t\tdepthTest: true,\r\n\t\t\tside: FrontSide\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\treturn cache[ 'DefaultMaterial' ];\r\n\r\n}\r\n\r\nfunction addUnknownExtensionsToUserData( knownExtensions, object, objectDef ) {\r\n\r\n\t// Add unknown glTF extensions to an object's userData.\r\n\r\n\tfor ( const name in objectDef.extensions ) {\r\n\r\n\t\tif ( knownExtensions[ name ] === undefined ) {\r\n\r\n\t\t\tobject.userData.gltfExtensions = object.userData.gltfExtensions || {};\r\n\t\t\tobject.userData.gltfExtensions[ name ] = objectDef.extensions[ name ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * @param {Object3D|Material|BufferGeometry} object\r\n * @param {GLTF.definition} gltfDef\r\n */\r\nfunction assignExtrasToUserData( object, gltfDef ) {\r\n\r\n\tif ( gltfDef.extras !== undefined ) {\r\n\r\n\t\tif ( typeof gltfDef.extras === 'object' ) {\r\n\r\n\t\t\tObject.assign( object.userData, gltfDef.extras );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\r\n *\r\n * @param {BufferGeometry} geometry\r\n * @param {Array<GLTF.Target>} targets\r\n * @param {GLTFParser} parser\r\n * @return {Promise<BufferGeometry>}\r\n */\r\nfunction addMorphTargets( geometry, targets, parser ) {\r\n\r\n\tlet hasMorphPosition = false;\r\n\tlet hasMorphNormal = false;\r\n\r\n\tfor ( let i = 0, il = targets.length; i < il; i ++ ) {\r\n\r\n\t\tconst target = targets[ i ];\r\n\r\n\t\tif ( target.POSITION !== undefined ) hasMorphPosition = true;\r\n\t\tif ( target.NORMAL !== undefined ) hasMorphNormal = true;\r\n\r\n\t\tif ( hasMorphPosition && hasMorphNormal ) break;\r\n\r\n\t}\r\n\r\n\tif ( ! hasMorphPosition && ! hasMorphNormal ) return Promise.resolve( geometry );\r\n\r\n\tconst pendingPositionAccessors = [];\r\n\tconst pendingNormalAccessors = [];\r\n\r\n\tfor ( let i = 0, il = targets.length; i < il; i ++ ) {\r\n\r\n\t\tconst target = targets[ i ];\r\n\r\n\t\tif ( hasMorphPosition ) {\r\n\r\n\t\t\tconst pendingAccessor = target.POSITION !== undefined\r\n\t\t\t\t? parser.getDependency( 'accessor', target.POSITION )\r\n\t\t\t\t: geometry.attributes.position;\r\n\r\n\t\t\tpendingPositionAccessors.push( pendingAccessor );\r\n\r\n\t\t}\r\n\r\n\t\tif ( hasMorphNormal ) {\r\n\r\n\t\t\tconst pendingAccessor = target.NORMAL !== undefined\r\n\t\t\t\t? parser.getDependency( 'accessor', target.NORMAL )\r\n\t\t\t\t: geometry.attributes.normal;\r\n\r\n\t\t\tpendingNormalAccessors.push( pendingAccessor );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn Promise.all( [\r\n\t\tPromise.all( pendingPositionAccessors ),\r\n\t\tPromise.all( pendingNormalAccessors )\r\n\t] ).then( function ( accessors ) {\r\n\r\n\t\tconst morphPositions = accessors[ 0 ];\r\n\t\tconst morphNormals = accessors[ 1 ];\r\n\r\n\t\tif ( hasMorphPosition ) geometry.morphAttributes.position = morphPositions;\r\n\t\tif ( hasMorphNormal ) geometry.morphAttributes.normal = morphNormals;\r\n\t\tgeometry.morphTargetsRelative = true;\r\n\r\n\t\treturn geometry;\r\n\r\n\t} );\r\n\r\n}\r\n\r\n/**\r\n * @param {Mesh} mesh\r\n * @param {GLTF.Mesh} meshDef\r\n */\r\nfunction updateMorphTargets( mesh, meshDef ) {\r\n\r\n\tmesh.updateMorphTargets();\r\n\r\n\tif ( meshDef.weights !== undefined ) {\r\n\r\n\t\tfor ( let i = 0, il = meshDef.weights.length; i < il; i ++ ) {\r\n\r\n\t\t\tmesh.morphTargetInfluences[ i ] = meshDef.weights[ i ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// .extras has user-defined data, so check that .extras.targetNames is an array.\r\n\tif ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) {\r\n\r\n\t\tconst targetNames = meshDef.extras.targetNames;\r\n\r\n\t\tif ( mesh.morphTargetInfluences.length === targetNames.length ) {\r\n\r\n\t\t\tmesh.morphTargetDictionary = {};\r\n\r\n\t\t\tfor ( let i = 0, il = targetNames.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tmesh.morphTargetDictionary[ targetNames[ i ] ] = i;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.' );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction createPrimitiveKey( primitiveDef ) {\r\n\r\n\tconst dracoExtension = primitiveDef.extensions && primitiveDef.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ];\r\n\tlet geometryKey;\r\n\r\n\tif ( dracoExtension ) {\r\n\r\n\t\tgeometryKey = 'draco:' + dracoExtension.bufferView\r\n\t\t\t\t+ ':' + dracoExtension.indices\r\n\t\t\t\t+ ':' + createAttributesKey( dracoExtension.attributes );\r\n\r\n\t} else {\r\n\r\n\t\tgeometryKey = primitiveDef.indices + ':' + createAttributesKey( primitiveDef.attributes ) + ':' + primitiveDef.mode;\r\n\r\n\t}\r\n\r\n\treturn geometryKey;\r\n\r\n}\r\n\r\nfunction createAttributesKey( attributes ) {\r\n\r\n\tlet attributesKey = '';\r\n\r\n\tconst keys = Object.keys( attributes ).sort();\r\n\r\n\tfor ( let i = 0, il = keys.length; i < il; i ++ ) {\r\n\r\n\t\tattributesKey += keys[ i ] + ':' + attributes[ keys[ i ] ] + ';';\r\n\r\n\t}\r\n\r\n\treturn attributesKey;\r\n\r\n}\r\n\r\nfunction getNormalizedComponentScale( constructor ) {\r\n\r\n\t// Reference:\r\n\t// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data\r\n\r\n\tswitch ( constructor ) {\r\n\r\n\t\tcase Int8Array:\r\n\t\t\treturn 1 / 127;\r\n\r\n\t\tcase Uint8Array:\r\n\t\t\treturn 1 / 255;\r\n\r\n\t\tcase Int16Array:\r\n\t\t\treturn 1 / 32767;\r\n\r\n\t\tcase Uint16Array:\r\n\t\t\treturn 1 / 65535;\r\n\r\n\t\tdefault:\r\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Unsupported normalized accessor component type.' );\r\n\r\n\t}\r\n\r\n}\r\n\r\n/* GLTF PARSER */\r\n\r\nclass GLTFParser {\r\n\r\n\tconstructor( json = {}, options = {} ) {\r\n\r\n\t\tthis.json = json;\r\n\t\tthis.extensions = {};\r\n\t\tthis.plugins = {};\r\n\t\tthis.options = options;\r\n\r\n\t\t// loader object cache\r\n\t\tthis.cache = new GLTFRegistry();\r\n\r\n\t\t// associations between Three.js objects and glTF elements\r\n\t\tthis.associations = new Map();\r\n\r\n\t\t// BufferGeometry caching\r\n\t\tthis.primitiveCache = {};\r\n\r\n\t\t// Object3D instance caches\r\n\t\tthis.meshCache = { refs: {}, uses: {} };\r\n\t\tthis.cameraCache = { refs: {}, uses: {} };\r\n\t\tthis.lightCache = { refs: {}, uses: {} };\r\n\r\n\t\tthis.textureCache = {};\r\n\r\n\t\t// Track node names, to ensure no duplicates\r\n\t\tthis.nodeNamesUsed = {};\r\n\r\n\t\t// Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the\r\n\t\t// expensive work of uploading a texture to the GPU off the main thread.\r\n\t\tif ( typeof createImageBitmap !== 'undefined' && /Firefox|Safari/.test( navigator.userAgent ) === false ) {\r\n\r\n\t\t\tthis.textureLoader = new ImageBitmapLoader( this.options.manager );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.textureLoader = new TextureLoader( this.options.manager );\r\n\r\n\t\t}\r\n\r\n\t\tthis.textureLoader.setCrossOrigin( this.options.crossOrigin );\r\n\t\tthis.textureLoader.setRequestHeader( this.options.requestHeader );\r\n\r\n\t\tthis.fileLoader = new FileLoader( this.options.manager );\r\n\t\tthis.fileLoader.setResponseType( 'arraybuffer' );\r\n\r\n\t\tif ( this.options.crossOrigin === 'use-credentials' ) {\r\n\r\n\t\t\tthis.fileLoader.setWithCredentials( true );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tsetExtensions( extensions ) {\r\n\r\n\t\tthis.extensions = extensions;\r\n\r\n\t}\r\n\r\n\tsetPlugins( plugins ) {\r\n\r\n\t\tthis.plugins = plugins;\r\n\r\n\t}\r\n\r\n\tparse( onLoad, onError ) {\r\n\r\n\t\tconst parser = this;\r\n\t\tconst json = this.json;\r\n\t\tconst extensions = this.extensions;\r\n\r\n\t\t// Clear the loader cache\r\n\t\tthis.cache.removeAll();\r\n\r\n\t\t// Mark the special nodes/meshes in json for efficient parse\r\n\t\tthis._invokeAll( function ( ext ) {\r\n\r\n\t\t\treturn ext._markDefs && ext._markDefs();\r\n\r\n\t\t} );\r\n\r\n\t\tPromise.all( this._invokeAll( function ( ext ) {\r\n\r\n\t\t\treturn ext.beforeRoot && ext.beforeRoot();\r\n\r\n\t\t} ) ).then( function () {\r\n\r\n\t\t\treturn Promise.all( [\r\n\r\n\t\t\t\tparser.getDependencies( 'scene' ),\r\n\t\t\t\tparser.getDependencies( 'animation' ),\r\n\t\t\t\tparser.getDependencies( 'camera' ),\r\n\r\n\t\t\t] );\r\n\r\n\t\t} ).then( function ( dependencies ) {\r\n\r\n\t\t\tconst result = {\r\n\t\t\t\tscene: dependencies[ 0 ][ json.scene || 0 ],\r\n\t\t\t\tscenes: dependencies[ 0 ],\r\n\t\t\t\tanimations: dependencies[ 1 ],\r\n\t\t\t\tcameras: dependencies[ 2 ],\r\n\t\t\t\tasset: json.asset,\r\n\t\t\t\tparser: parser,\r\n\t\t\t\tuserData: {}\r\n\t\t\t};\r\n\r\n\t\t\taddUnknownExtensionsToUserData( extensions, result, json );\r\n\r\n\t\t\tassignExtrasToUserData( result, json );\r\n\r\n\t\t\tPromise.all( parser._invokeAll( function ( ext ) {\r\n\r\n\t\t\t\treturn ext.afterRoot && ext.afterRoot( result );\r\n\r\n\t\t\t} ) ).then( function () {\r\n\r\n\t\t\t\tonLoad( result );\r\n\r\n\t\t\t} );\r\n\r\n\t\t} ).catch( onError );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Marks the special nodes/meshes in json for efficient parse.\r\n\t */\r\n\t_markDefs() {\r\n\r\n\t\tconst nodeDefs = this.json.nodes || [];\r\n\t\tconst skinDefs = this.json.skins || [];\r\n\t\tconst meshDefs = this.json.meshes || [];\r\n\r\n\t\t// Nothing in the node definition indicates whether it is a Bone or an\r\n\t\t// Object3D. Use the skins' joint references to mark bones.\r\n\t\tfor ( let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex ++ ) {\r\n\r\n\t\t\tconst joints = skinDefs[ skinIndex ].joints;\r\n\r\n\t\t\tfor ( let i = 0, il = joints.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tnodeDefs[ joints[ i ] ].isBone = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Iterate over all nodes, marking references to shared resources,\r\n\t\t// as well as skeleton joints.\r\n\t\tfor ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {\r\n\r\n\t\t\tconst nodeDef = nodeDefs[ nodeIndex ];\r\n\r\n\t\t\tif ( nodeDef.mesh !== undefined ) {\r\n\r\n\t\t\t\tthis._addNodeRef( this.meshCache, nodeDef.mesh );\r\n\r\n\t\t\t\t// Nothing in the mesh definition indicates whether it is\r\n\t\t\t\t// a SkinnedMesh or Mesh. Use the node's mesh reference\r\n\t\t\t\t// to mark SkinnedMesh if node has skin.\r\n\t\t\t\tif ( nodeDef.skin !== undefined ) {\r\n\r\n\t\t\t\t\tmeshDefs[ nodeDef.mesh ].isSkinnedMesh = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( nodeDef.camera !== undefined ) {\r\n\r\n\t\t\t\tthis._addNodeRef( this.cameraCache, nodeDef.camera );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Counts references to shared node / Object3D resources. These resources\r\n\t * can be reused, or \"instantiated\", at multiple nodes in the scene\r\n\t * hierarchy. Mesh, Camera, and Light instances are instantiated and must\r\n\t * be marked. Non-scenegraph resources (like Materials, Geometries, and\r\n\t * Textures) can be reused directly and are not marked here.\r\n\t *\r\n\t * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\r\n\t */\r\n\t_addNodeRef( cache, index ) {\r\n\r\n\t\tif ( index === undefined ) return;\r\n\r\n\t\tif ( cache.refs[ index ] === undefined ) {\r\n\r\n\t\t\tcache.refs[ index ] = cache.uses[ index ] = 0;\r\n\r\n\t\t}\r\n\r\n\t\tcache.refs[ index ] ++;\r\n\r\n\t}\r\n\r\n\t/** Returns a reference to a shared resource, cloning it if necessary. */\r\n\t_getNodeRef( cache, index, object ) {\r\n\r\n\t\tif ( cache.refs[ index ] <= 1 ) return object;\r\n\r\n\t\tconst ref = object.clone();\r\n\r\n\t\t// Propagates mappings to the cloned object, prevents mappings on the\r\n\t\t// original object from being lost.\r\n\t\tconst updateMappings = ( original, clone ) => {\r\n\r\n\t\t\tconst mappings = this.associations.get( original );\r\n\t\t\tif ( mappings != null ) {\r\n\r\n\t\t\t\tthis.associations.set( clone, mappings );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( const [ i, child ] of original.children.entries() ) {\r\n\r\n\t\t\t\tupdateMappings( child, clone.children[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\tupdateMappings( object, ref );\r\n\r\n\t\tref.name += '_instance_' + ( cache.uses[ index ] ++ );\r\n\r\n\t\treturn ref;\r\n\r\n\t}\r\n\r\n\t_invokeOne( func ) {\r\n\r\n\t\tconst extensions = Object.values( this.plugins );\r\n\t\textensions.push( this );\r\n\r\n\t\tfor ( let i = 0; i < extensions.length; i ++ ) {\r\n\r\n\t\t\tconst result = func( extensions[ i ] );\r\n\r\n\t\t\tif ( result ) return result;\r\n\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\r\n\t}\r\n\r\n\t_invokeAll( func ) {\r\n\r\n\t\tconst extensions = Object.values( this.plugins );\r\n\t\textensions.unshift( this );\r\n\r\n\t\tconst pending = [];\r\n\r\n\t\tfor ( let i = 0; i < extensions.length; i ++ ) {\r\n\r\n\t\t\tconst result = func( extensions[ i ] );\r\n\r\n\t\t\tif ( result ) pending.push( result );\r\n\r\n\t\t}\r\n\r\n\t\treturn pending;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Requests the specified dependency asynchronously, with caching.\r\n\t * @param {string} type\r\n\t * @param {number} index\r\n\t * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\r\n\t */\r\n\tgetDependency( type, index ) {\r\n\r\n\t\tconst cacheKey = type + ':' + index;\r\n\t\tlet dependency = this.cache.get( cacheKey );\r\n\r\n\t\tif ( ! dependency ) {\r\n\r\n\t\t\tswitch ( type ) {\r\n\r\n\t\t\t\tcase 'scene':\r\n\t\t\t\t\tdependency = this.loadScene( index );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'node':\r\n\t\t\t\t\tdependency = this.loadNode( index );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'mesh':\r\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\r\n\r\n\t\t\t\t\t\treturn ext.loadMesh && ext.loadMesh( index );\r\n\r\n\t\t\t\t\t} );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'accessor':\r\n\t\t\t\t\tdependency = this.loadAccessor( index );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'bufferView':\r\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\r\n\r\n\t\t\t\t\t\treturn ext.loadBufferView && ext.loadBufferView( index );\r\n\r\n\t\t\t\t\t} );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'buffer':\r\n\t\t\t\t\tdependency = this.loadBuffer( index );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'material':\r\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\r\n\r\n\t\t\t\t\t\treturn ext.loadMaterial && ext.loadMaterial( index );\r\n\r\n\t\t\t\t\t} );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'texture':\r\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\r\n\r\n\t\t\t\t\t\treturn ext.loadTexture && ext.loadTexture( index );\r\n\r\n\t\t\t\t\t} );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'skin':\r\n\t\t\t\t\tdependency = this.loadSkin( index );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'animation':\r\n\t\t\t\t\tdependency = this.loadAnimation( index );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'camera':\r\n\t\t\t\t\tdependency = this.loadCamera( index );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow new Error( 'Unknown type: ' + type );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.cache.add( cacheKey, dependency );\r\n\r\n\t\t}\r\n\r\n\t\treturn dependency;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Requests all dependencies of the specified type asynchronously, with caching.\r\n\t * @param {string} type\r\n\t * @return {Promise<Array<Object>>}\r\n\t */\r\n\tgetDependencies( type ) {\r\n\r\n\t\tlet dependencies = this.cache.get( type );\r\n\r\n\t\tif ( ! dependencies ) {\r\n\r\n\t\t\tconst parser = this;\r\n\t\t\tconst defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || [];\r\n\r\n\t\t\tdependencies = Promise.all( defs.map( function ( def, index ) {\r\n\r\n\t\t\t\treturn parser.getDependency( type, index );\r\n\r\n\t\t\t} ) );\r\n\r\n\t\t\tthis.cache.add( type, dependencies );\r\n\r\n\t\t}\r\n\r\n\t\treturn dependencies;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\r\n\t * @param {number} bufferIndex\r\n\t * @return {Promise<ArrayBuffer>}\r\n\t */\r\n\tloadBuffer( bufferIndex ) {\r\n\r\n\t\tconst bufferDef = this.json.buffers[ bufferIndex ];\r\n\t\tconst loader = this.fileLoader;\r\n\r\n\t\tif ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) {\r\n\r\n\t\t\tthrow new Error( 'THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' );\r\n\r\n\t\t}\r\n\r\n\t\t// If present, GLB container is required to be the first buffer.\r\n\t\tif ( bufferDef.uri === undefined && bufferIndex === 0 ) {\r\n\r\n\t\t\treturn Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body );\r\n\r\n\t\t}\r\n\r\n\t\tconst options = this.options;\r\n\r\n\t\treturn new Promise( function ( resolve, reject ) {\r\n\r\n\t\t\tloader.load( LoaderUtils.resolveURL( bufferDef.uri, options.path ), resolve, undefined, function () {\r\n\r\n\t\t\t\treject( new Error( 'THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".' ) );\r\n\r\n\t\t\t} );\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\r\n\t * @param {number} bufferViewIndex\r\n\t * @return {Promise<ArrayBuffer>}\r\n\t */\r\n\tloadBufferView( bufferViewIndex ) {\r\n\r\n\t\tconst bufferViewDef = this.json.bufferViews[ bufferViewIndex ];\r\n\r\n\t\treturn this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) {\r\n\r\n\t\t\tconst byteLength = bufferViewDef.byteLength || 0;\r\n\t\t\tconst byteOffset = bufferViewDef.byteOffset || 0;\r\n\t\t\treturn buffer.slice( byteOffset, byteOffset + byteLength );\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\r\n\t * @param {number} accessorIndex\r\n\t * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\r\n\t */\r\n\tloadAccessor( accessorIndex ) {\r\n\r\n\t\tconst parser = this;\r\n\t\tconst json = this.json;\r\n\r\n\t\tconst accessorDef = this.json.accessors[ accessorIndex ];\r\n\r\n\t\tif ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) {\r\n\r\n\t\t\t// Ignore empty accessors, which may be used to declare runtime\r\n\t\t\t// information about attributes coming from another source (e.g. Draco\r\n\t\t\t// compression extension).\r\n\t\t\treturn Promise.resolve( null );\r\n\r\n\t\t}\r\n\r\n\t\tconst pendingBufferViews = [];\r\n\r\n\t\tif ( accessorDef.bufferView !== undefined ) {\r\n\r\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tpendingBufferViews.push( null );\r\n\r\n\t\t}\r\n\r\n\t\tif ( accessorDef.sparse !== undefined ) {\r\n\r\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) );\r\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.all( pendingBufferViews ).then( function ( bufferViews ) {\r\n\r\n\t\t\tconst bufferView = bufferViews[ 0 ];\r\n\r\n\t\t\tconst itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];\r\n\t\t\tconst TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\r\n\r\n\t\t\t// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\r\n\t\t\tconst elementBytes = TypedArray.BYTES_PER_ELEMENT;\r\n\t\t\tconst itemBytes = elementBytes * itemSize;\r\n\t\t\tconst byteOffset = accessorDef.byteOffset || 0;\r\n\t\t\tconst byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[ accessorDef.bufferView ].byteStride : undefined;\r\n\t\t\tconst normalized = accessorDef.normalized === true;\r\n\t\t\tlet array, bufferAttribute;\r\n\r\n\t\t\t// The buffer is not interleaved if the stride is the item size in bytes.\r\n\t\t\tif ( byteStride && byteStride !== itemBytes ) {\r\n\r\n\t\t\t\t// Each \"slice\" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer\r\n\t\t\t\t// This makes sure that IBA.count reflects accessor.count properly\r\n\t\t\t\tconst ibSlice = Math.floor( byteOffset / byteStride );\r\n\t\t\t\tconst ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;\r\n\t\t\t\tlet ib = parser.cache.get( ibCacheKey );\r\n\r\n\t\t\t\tif ( ! ib ) {\r\n\r\n\t\t\t\t\tarray = new TypedArray( bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes );\r\n\r\n\t\t\t\t\t// Integer parameters to IB/IBA are in array elements, not bytes.\r\n\t\t\t\t\tib = new InterleavedBuffer( array, byteStride / elementBytes );\r\n\r\n\t\t\t\t\tparser.cache.add( ibCacheKey, ib );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbufferAttribute = new InterleavedBufferAttribute( ib, itemSize, ( byteOffset % byteStride ) / elementBytes, normalized );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( bufferView === null ) {\r\n\r\n\t\t\t\t\tarray = new TypedArray( accessorDef.count * itemSize );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tarray = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbufferAttribute = new BufferAttribute( array, itemSize, normalized );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\r\n\t\t\tif ( accessorDef.sparse !== undefined ) {\r\n\r\n\t\t\t\tconst itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\r\n\t\t\t\tconst TypedArrayIndices = WEBGL_COMPONENT_TYPES[ accessorDef.sparse.indices.componentType ];\r\n\r\n\t\t\t\tconst byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\r\n\t\t\t\tconst byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\r\n\r\n\t\t\t\tconst sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices );\r\n\t\t\t\tconst sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize );\r\n\r\n\t\t\t\tif ( bufferView !== null ) {\r\n\r\n\t\t\t\t\t// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\r\n\t\t\t\t\tbufferAttribute = new BufferAttribute( bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( let i = 0, il = sparseIndices.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tconst index = sparseIndices[ i ];\r\n\r\n\t\t\t\t\tbufferAttribute.setX( index, sparseValues[ i * itemSize ] );\r\n\t\t\t\t\tif ( itemSize >= 2 ) bufferAttribute.setY( index, sparseValues[ i * itemSize + 1 ] );\r\n\t\t\t\t\tif ( itemSize >= 3 ) bufferAttribute.setZ( index, sparseValues[ i * itemSize + 2 ] );\r\n\t\t\t\t\tif ( itemSize >= 4 ) bufferAttribute.setW( index, sparseValues[ i * itemSize + 3 ] );\r\n\t\t\t\t\tif ( itemSize >= 5 ) throw new Error( 'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn bufferAttribute;\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\r\n\t * @param {number} textureIndex\r\n\t * @return {Promise<THREE.Texture>}\r\n\t */\r\n\tloadTexture( textureIndex ) {\r\n\r\n\t\tconst json = this.json;\r\n\t\tconst options = this.options;\r\n\t\tconst textureDef = json.textures[ textureIndex ];\r\n\t\tconst source = json.images[ textureDef.source ];\r\n\r\n\t\tlet loader = this.textureLoader;\r\n\r\n\t\tif ( source.uri ) {\r\n\r\n\t\t\tconst handler = options.manager.getHandler( source.uri );\r\n\t\t\tif ( handler !== null ) loader = handler;\r\n\r\n\t\t}\r\n\r\n\t\treturn this.loadTextureImage( textureIndex, source, loader );\r\n\r\n\t}\r\n\r\n\tloadTextureImage( textureIndex, source, loader ) {\r\n\r\n\t\tconst parser = this;\r\n\t\tconst json = this.json;\r\n\t\tconst options = this.options;\r\n\r\n\t\tconst textureDef = json.textures[ textureIndex ];\r\n\r\n\t\tconst cacheKey = ( source.uri || source.bufferView ) + ':' + textureDef.sampler;\r\n\r\n\t\tif ( this.textureCache[ cacheKey ] ) {\r\n\r\n\t\t\t// See https://github.com/mrdoob/three.js/issues/21559.\r\n\t\t\treturn this.textureCache[ cacheKey ];\r\n\r\n\t\t}\r\n\r\n\t\tconst URL = self.URL || self.webkitURL;\r\n\r\n\t\tlet sourceURI = source.uri || '';\r\n\t\tlet isObjectURL = false;\r\n\r\n\t\tif ( source.bufferView !== undefined ) {\r\n\r\n\t\t\t// Load binary image data from bufferView, if provided.\r\n\r\n\t\t\tsourceURI = parser.getDependency( 'bufferView', source.bufferView ).then( function ( bufferView ) {\r\n\r\n\t\t\t\tisObjectURL = true;\r\n\t\t\t\tconst blob = new Blob( [ bufferView ], { type: source.mimeType } );\r\n\t\t\t\tsourceURI = URL.createObjectURL( blob );\r\n\t\t\t\treturn sourceURI;\r\n\r\n\t\t\t} );\r\n\r\n\t\t} else if ( source.uri === undefined ) {\r\n\r\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Image ' + textureIndex + ' is missing URI and bufferView' );\r\n\r\n\t\t}\r\n\r\n\t\tconst promise = Promise.resolve( sourceURI ).then( function ( sourceURI ) {\r\n\r\n\t\t\treturn new Promise( function ( resolve, reject ) {\r\n\r\n\t\t\t\tlet onLoad = resolve;\r\n\r\n\t\t\t\tif ( loader.isImageBitmapLoader === true ) {\r\n\r\n\t\t\t\t\tonLoad = function ( imageBitmap ) {\r\n\r\n\t\t\t\t\t\tconst texture = new Texture( imageBitmap );\r\n\t\t\t\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\t\t\t\tresolve( texture );\r\n\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tloader.load( LoaderUtils.resolveURL( sourceURI, options.path ), onLoad, undefined, reject );\r\n\r\n\t\t\t} );\r\n\r\n\t\t} ).then( function ( texture ) {\r\n\r\n\t\t\t// Clean up resources and configure Texture.\r\n\r\n\t\t\tif ( isObjectURL === true ) {\r\n\r\n\t\t\t\tURL.revokeObjectURL( sourceURI );\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttexture.flipY = false;\r\n\r\n\t\t\tif ( textureDef.name ) texture.name = textureDef.name;\r\n\r\n\t\t\tconst samplers = json.samplers || {};\r\n\t\t\tconst sampler = samplers[ textureDef.sampler ] || {};\r\n\r\n\t\t\ttexture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || LinearFilter;\r\n\t\t\ttexture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || LinearMipmapLinearFilter;\r\n\t\t\ttexture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || RepeatWrapping;\r\n\t\t\ttexture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || RepeatWrapping;\r\n\r\n\t\t\tparser.associations.set( texture, { textures: textureIndex } );\r\n\r\n\t\t\treturn texture;\r\n\r\n\t\t} ).catch( function () {\r\n\r\n\t\t\tconsole.error( 'THREE.GLTFLoader: Couldn\\'t load texture', sourceURI );\r\n\t\t\treturn null;\r\n\r\n\t\t} );\r\n\r\n\t\tthis.textureCache[ cacheKey ] = promise;\r\n\r\n\t\treturn promise;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Asynchronously assigns a texture to the given material parameters.\r\n\t * @param {Object} materialParams\r\n\t * @param {string} mapName\r\n\t * @param {Object} mapDef\r\n\t * @return {Promise<Texture>}\r\n\t */\r\n\tassignTexture( materialParams, mapName, mapDef ) {\r\n\r\n\t\tconst parser = this;\r\n\r\n\t\treturn this.getDependency( 'texture', mapDef.index ).then( function ( texture ) {\r\n\r\n\t\t\t// Materials sample aoMap from UV set 1 and other maps from UV set 0 - this can't be configured\r\n\t\t\t// However, we will copy UV set 0 to UV set 1 on demand for aoMap\r\n\t\t\tif ( mapDef.texCoord !== undefined && mapDef.texCoord != 0 && ! ( mapName === 'aoMap' && mapDef.texCoord == 1 ) ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Custom UV set ' + mapDef.texCoord + ' for texture ' + mapName + ' not yet supported.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] ) {\r\n\r\n\t\t\t\tconst transform = mapDef.extensions !== undefined ? mapDef.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] : undefined;\r\n\r\n\t\t\t\tif ( transform ) {\r\n\r\n\t\t\t\t\tconst gltfReference = parser.associations.get( texture );\r\n\t\t\t\t\ttexture = parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ].extendTexture( texture, transform );\r\n\t\t\t\t\tparser.associations.set( texture, gltfReference );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmaterialParams[ mapName ] = texture;\r\n\r\n\t\t\treturn texture;\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Assigns final material to a Mesh, Line, or Points instance. The instance\r\n\t * already has a material (generated from the glTF material options alone)\r\n\t * but reuse of the same glTF material may require multiple threejs materials\r\n\t * to accommodate different primitive types, defines, etc. New materials will\r\n\t * be created if necessary, and reused from a cache.\r\n\t * @param  {Object3D} mesh Mesh, Line, or Points instance.\r\n\t */\r\n\tassignFinalMaterial( mesh ) {\r\n\r\n\t\tconst geometry = mesh.geometry;\r\n\t\tlet material = mesh.material;\r\n\r\n\t\tconst useDerivativeTangents = geometry.attributes.tangent === undefined;\r\n\t\tconst useVertexColors = geometry.attributes.color !== undefined;\r\n\t\tconst useFlatShading = geometry.attributes.normal === undefined;\r\n\r\n\t\tif ( mesh.isPoints ) {\r\n\r\n\t\t\tconst cacheKey = 'PointsMaterial:' + material.uuid;\r\n\r\n\t\t\tlet pointsMaterial = this.cache.get( cacheKey );\r\n\r\n\t\t\tif ( ! pointsMaterial ) {\r\n\r\n\t\t\t\tpointsMaterial = new PointsMaterial();\r\n\t\t\t\tMaterial.prototype.copy.call( pointsMaterial, material );\r\n\t\t\t\tpointsMaterial.color.copy( material.color );\r\n\t\t\t\tpointsMaterial.map = material.map;\r\n\t\t\t\tpointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px\r\n\r\n\t\t\t\tthis.cache.add( cacheKey, pointsMaterial );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmaterial = pointsMaterial;\r\n\r\n\t\t} else if ( mesh.isLine ) {\r\n\r\n\t\t\tconst cacheKey = 'LineBasicMaterial:' + material.uuid;\r\n\r\n\t\t\tlet lineMaterial = this.cache.get( cacheKey );\r\n\r\n\t\t\tif ( ! lineMaterial ) {\r\n\r\n\t\t\t\tlineMaterial = new LineBasicMaterial();\r\n\t\t\t\tMaterial.prototype.copy.call( lineMaterial, material );\r\n\t\t\t\tlineMaterial.color.copy( material.color );\r\n\r\n\t\t\t\tthis.cache.add( cacheKey, lineMaterial );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmaterial = lineMaterial;\r\n\r\n\t\t}\r\n\r\n\t\t// Clone the material if it will be modified\r\n\t\tif ( useDerivativeTangents || useVertexColors || useFlatShading ) {\r\n\r\n\t\t\tlet cacheKey = 'ClonedMaterial:' + material.uuid + ':';\r\n\r\n\t\t\tif ( material.isGLTFSpecularGlossinessMaterial ) cacheKey += 'specular-glossiness:';\r\n\t\t\tif ( useDerivativeTangents ) cacheKey += 'derivative-tangents:';\r\n\t\t\tif ( useVertexColors ) cacheKey += 'vertex-colors:';\r\n\t\t\tif ( useFlatShading ) cacheKey += 'flat-shading:';\r\n\r\n\t\t\tlet cachedMaterial = this.cache.get( cacheKey );\r\n\r\n\t\t\tif ( ! cachedMaterial ) {\r\n\r\n\t\t\t\tcachedMaterial = material.clone();\r\n\r\n\t\t\t\tif ( useVertexColors ) cachedMaterial.vertexColors = true;\r\n\t\t\t\tif ( useFlatShading ) cachedMaterial.flatShading = true;\r\n\r\n\t\t\t\tif ( useDerivativeTangents ) {\r\n\r\n\t\t\t\t\t// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\r\n\t\t\t\t\tif ( cachedMaterial.normalScale ) cachedMaterial.normalScale.y *= - 1;\r\n\t\t\t\t\tif ( cachedMaterial.clearcoatNormalScale ) cachedMaterial.clearcoatNormalScale.y *= - 1;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.cache.add( cacheKey, cachedMaterial );\r\n\r\n\t\t\t\tthis.associations.set( cachedMaterial, this.associations.get( material ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmaterial = cachedMaterial;\r\n\r\n\t\t}\r\n\r\n\t\t// workarounds for mesh and geometry\r\n\r\n\t\tif ( material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined ) {\r\n\r\n\t\t\tgeometry.setAttribute( 'uv2', geometry.attributes.uv );\r\n\r\n\t\t}\r\n\r\n\t\tmesh.material = material;\r\n\r\n\t}\r\n\r\n\tgetMaterialType( /* materialIndex */ ) {\r\n\r\n\t\treturn MeshStandardMaterial;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\r\n\t * @param {number} materialIndex\r\n\t * @return {Promise<Material>}\r\n\t */\r\n\tloadMaterial( materialIndex ) {\r\n\r\n\t\tconst parser = this;\r\n\t\tconst json = this.json;\r\n\t\tconst extensions = this.extensions;\r\n\t\tconst materialDef = json.materials[ materialIndex ];\r\n\r\n\t\tlet materialType;\r\n\t\tconst materialParams = {};\r\n\t\tconst materialExtensions = materialDef.extensions || {};\r\n\r\n\t\tconst pending = [];\r\n\r\n\t\tif ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ] ) {\r\n\r\n\t\t\tconst sgExtension = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ];\r\n\t\t\tmaterialType = sgExtension.getMaterialType();\r\n\t\t\tpending.push( sgExtension.extendParams( materialParams, materialDef, parser ) );\r\n\r\n\t\t} else if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] ) {\r\n\r\n\t\t\tconst kmuExtension = extensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ];\r\n\t\t\tmaterialType = kmuExtension.getMaterialType();\r\n\t\t\tpending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// Specification:\r\n\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\r\n\r\n\t\t\tconst metallicRoughness = materialDef.pbrMetallicRoughness || {};\r\n\r\n\t\t\tmaterialParams.color = new Color( 1.0, 1.0, 1.0 );\r\n\t\t\tmaterialParams.opacity = 1.0;\r\n\r\n\t\t\tif ( Array.isArray( metallicRoughness.baseColorFactor ) ) {\r\n\r\n\t\t\t\tconst array = metallicRoughness.baseColorFactor;\r\n\r\n\t\t\t\tmaterialParams.color.fromArray( array );\r\n\t\t\t\tmaterialParams.opacity = array[ 3 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( metallicRoughness.baseColorTexture !== undefined ) {\r\n\r\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmaterialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;\r\n\t\t\tmaterialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;\r\n\r\n\t\t\tif ( metallicRoughness.metallicRoughnessTexture !== undefined ) {\r\n\r\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture ) );\r\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmaterialType = this._invokeOne( function ( ext ) {\r\n\r\n\t\t\t\treturn ext.getMaterialType && ext.getMaterialType( materialIndex );\r\n\r\n\t\t\t} );\r\n\r\n\t\t\tpending.push( Promise.all( this._invokeAll( function ( ext ) {\r\n\r\n\t\t\t\treturn ext.extendMaterialParams && ext.extendMaterialParams( materialIndex, materialParams );\r\n\r\n\t\t\t} ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( materialDef.doubleSided === true ) {\r\n\r\n\t\t\tmaterialParams.side = DoubleSide;\r\n\r\n\t\t}\r\n\r\n\t\tconst alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\r\n\r\n\t\tif ( alphaMode === ALPHA_MODES.BLEND ) {\r\n\r\n\t\t\tmaterialParams.transparent = true;\r\n\r\n\t\t\t// See: https://github.com/mrdoob/three.js/issues/17706\r\n\t\t\tmaterialParams.depthWrite = false;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmaterialParams.format = RGBFormat;\r\n\t\t\tmaterialParams.transparent = false;\r\n\r\n\t\t\tif ( alphaMode === ALPHA_MODES.MASK ) {\r\n\r\n\t\t\t\tmaterialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial ) {\r\n\r\n\t\t\tpending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture ) );\r\n\r\n\t\t\tmaterialParams.normalScale = new Vector2( 1, 1 );\r\n\r\n\t\t\tif ( materialDef.normalTexture.scale !== undefined ) {\r\n\r\n\t\t\t\tconst scale = materialDef.normalTexture.scale;\r\n\r\n\t\t\t\tmaterialParams.normalScale.set( scale, scale );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial ) {\r\n\r\n\t\t\tpending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture ) );\r\n\r\n\t\t\tif ( materialDef.occlusionTexture.strength !== undefined ) {\r\n\r\n\t\t\t\tmaterialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial ) {\r\n\r\n\t\t\tmaterialParams.emissive = new Color().fromArray( materialDef.emissiveFactor );\r\n\r\n\t\t}\r\n\r\n\t\tif ( materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial ) {\r\n\r\n\t\t\tpending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.all( pending ).then( function () {\r\n\r\n\t\t\tlet material;\r\n\r\n\t\t\tif ( materialType === GLTFMeshStandardSGMaterial ) {\r\n\r\n\t\t\t\tmaterial = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ].createMaterial( materialParams );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tmaterial = new materialType( materialParams );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( materialDef.name ) material.name = materialDef.name;\r\n\r\n\t\t\t// baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding.\r\n\t\t\tif ( material.map ) material.map.encoding = sRGBEncoding;\r\n\t\t\tif ( material.emissiveMap ) material.emissiveMap.encoding = sRGBEncoding;\r\n\r\n\t\t\tassignExtrasToUserData( material, materialDef );\r\n\r\n\t\t\tparser.associations.set( material, { materials: materialIndex } );\r\n\r\n\t\t\tif ( materialDef.extensions ) addUnknownExtensionsToUserData( extensions, material, materialDef );\r\n\r\n\t\t\treturn material;\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\t/** When Object3D instances are targeted by animation, they need unique names. */\r\n\tcreateUniqueName( originalName ) {\r\n\r\n\t\tconst sanitizedName = PropertyBinding.sanitizeNodeName( originalName || '' );\r\n\r\n\t\tlet name = sanitizedName;\r\n\r\n\t\tfor ( let i = 1; this.nodeNamesUsed[ name ]; ++ i ) {\r\n\r\n\t\t\tname = sanitizedName + '_' + i;\r\n\r\n\t\t}\r\n\r\n\t\tthis.nodeNamesUsed[ name ] = true;\r\n\r\n\t\treturn name;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\r\n\t *\r\n\t * Creates BufferGeometries from primitives.\r\n\t *\r\n\t * @param {Array<GLTF.Primitive>} primitives\r\n\t * @return {Promise<Array<BufferGeometry>>}\r\n\t */\r\n\tloadGeometries( primitives ) {\r\n\r\n\t\tconst parser = this;\r\n\t\tconst extensions = this.extensions;\r\n\t\tconst cache = this.primitiveCache;\r\n\r\n\t\tfunction createDracoPrimitive( primitive ) {\r\n\r\n\t\t\treturn extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ]\r\n\t\t\t\t.decodePrimitive( primitive, parser )\r\n\t\t\t\t.then( function ( geometry ) {\r\n\r\n\t\t\t\t\treturn addPrimitiveAttributes( geometry, primitive, parser );\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t\tconst pending = [];\r\n\r\n\t\tfor ( let i = 0, il = primitives.length; i < il; i ++ ) {\r\n\r\n\t\t\tconst primitive = primitives[ i ];\r\n\t\t\tconst cacheKey = createPrimitiveKey( primitive );\r\n\r\n\t\t\t// See if we've already created this geometry\r\n\t\t\tconst cached = cache[ cacheKey ];\r\n\r\n\t\t\tif ( cached ) {\r\n\r\n\t\t\t\t// Use the cached geometry if it exists\r\n\t\t\t\tpending.push( cached.promise );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tlet geometryPromise;\r\n\r\n\t\t\t\tif ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) {\r\n\r\n\t\t\t\t\t// Use DRACO geometry if available\r\n\t\t\t\t\tgeometryPromise = createDracoPrimitive( primitive );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// Otherwise create a new geometry\r\n\t\t\t\t\tgeometryPromise = addPrimitiveAttributes( new BufferGeometry(), primitive, parser );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Cache this geometry\r\n\t\t\t\tcache[ cacheKey ] = { primitive: primitive, promise: geometryPromise };\r\n\r\n\t\t\t\tpending.push( geometryPromise );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.all( pending );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\r\n\t * @param {number} meshIndex\r\n\t * @return {Promise<Group|Mesh|SkinnedMesh>}\r\n\t */\r\n\tloadMesh( meshIndex ) {\r\n\r\n\t\tconst parser = this;\r\n\t\tconst json = this.json;\r\n\t\tconst extensions = this.extensions;\r\n\r\n\t\tconst meshDef = json.meshes[ meshIndex ];\r\n\t\tconst primitives = meshDef.primitives;\r\n\r\n\t\tconst pending = [];\r\n\r\n\t\tfor ( let i = 0, il = primitives.length; i < il; i ++ ) {\r\n\r\n\t\t\tconst material = primitives[ i ].material === undefined\r\n\t\t\t\t? createDefaultMaterial( this.cache )\r\n\t\t\t\t: this.getDependency( 'material', primitives[ i ].material );\r\n\r\n\t\t\tpending.push( material );\r\n\r\n\t\t}\r\n\r\n\t\tpending.push( parser.loadGeometries( primitives ) );\r\n\r\n\t\treturn Promise.all( pending ).then( function ( results ) {\r\n\r\n\t\t\tconst materials = results.slice( 0, results.length - 1 );\r\n\t\t\tconst geometries = results[ results.length - 1 ];\r\n\r\n\t\t\tconst meshes = [];\r\n\r\n\t\t\tfor ( let i = 0, il = geometries.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tconst geometry = geometries[ i ];\r\n\t\t\t\tconst primitive = primitives[ i ];\r\n\r\n\t\t\t\t// 1. create Mesh\r\n\r\n\t\t\t\tlet mesh;\r\n\r\n\t\t\t\tconst material = materials[ i ];\r\n\r\n\t\t\t\tif ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||\r\n\t\t\t\t\t\tprimitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||\r\n\t\t\t\t\t\tprimitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||\r\n\t\t\t\t\t\tprimitive.mode === undefined ) {\r\n\r\n\t\t\t\t\t// .isSkinnedMesh isn't in glTF spec. See ._markDefs()\r\n\t\t\t\t\tmesh = meshDef.isSkinnedMesh === true\r\n\t\t\t\t\t\t? new SkinnedMesh( geometry, material )\r\n\t\t\t\t\t\t: new Mesh( geometry, material );\r\n\r\n\t\t\t\t\tif ( mesh.isSkinnedMesh === true && ! mesh.geometry.attributes.skinWeight.normalized ) {\r\n\r\n\t\t\t\t\t\t// we normalize floating point skin weight array to fix malformed assets (see #15319)\r\n\t\t\t\t\t\t// it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs\r\n\t\t\t\t\t\tmesh.normalizeSkinWeights();\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ) {\r\n\r\n\t\t\t\t\t\tmesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleStripDrawMode );\r\n\r\n\t\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ) {\r\n\r\n\t\t\t\t\t\tmesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleFanDrawMode );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) {\r\n\r\n\t\t\t\t\tmesh = new LineSegments( geometry, material );\r\n\r\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_STRIP ) {\r\n\r\n\t\t\t\t\tmesh = new Line( geometry, material );\r\n\r\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_LOOP ) {\r\n\r\n\t\t\t\t\tmesh = new LineLoop( geometry, material );\r\n\r\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.POINTS ) {\r\n\r\n\t\t\t\t\tmesh = new Points( geometry, material );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( Object.keys( mesh.geometry.morphAttributes ).length > 0 ) {\r\n\r\n\t\t\t\t\tupdateMorphTargets( mesh, meshDef );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tmesh.name = parser.createUniqueName( meshDef.name || ( 'mesh_' + meshIndex ) );\r\n\r\n\t\t\t\tassignExtrasToUserData( mesh, meshDef );\r\n\r\n\t\t\t\tif ( primitive.extensions ) addUnknownExtensionsToUserData( extensions, mesh, primitive );\r\n\r\n\t\t\t\tparser.assignFinalMaterial( mesh );\r\n\r\n\t\t\t\tmeshes.push( mesh );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( let i = 0, il = meshes.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tparser.associations.set( meshes[ i ], {\r\n\t\t\t\t\tmeshes: meshIndex,\r\n\t\t\t\t\tprimitives: i\r\n\t\t\t\t} );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( meshes.length === 1 ) {\r\n\r\n\t\t\t\treturn meshes[ 0 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst group = new Group();\r\n\r\n\t\t\tparser.associations.set( group, { meshes: meshIndex } );\r\n\r\n\t\t\tfor ( let i = 0, il = meshes.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tgroup.add( meshes[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn group;\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\r\n\t * @param {number} cameraIndex\r\n\t * @return {Promise<THREE.Camera>}\r\n\t */\r\n\tloadCamera( cameraIndex ) {\r\n\r\n\t\tlet camera;\r\n\t\tconst cameraDef = this.json.cameras[ cameraIndex ];\r\n\t\tconst params = cameraDef[ cameraDef.type ];\r\n\r\n\t\tif ( ! params ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing camera parameters.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif ( cameraDef.type === 'perspective' ) {\r\n\r\n\t\t\tcamera = new PerspectiveCamera( MathUtils.radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 );\r\n\r\n\t\t} else if ( cameraDef.type === 'orthographic' ) {\r\n\r\n\t\t\tcamera = new OrthographicCamera( - params.xmag, params.xmag, params.ymag, - params.ymag, params.znear, params.zfar );\r\n\r\n\t\t}\r\n\r\n\t\tif ( cameraDef.name ) camera.name = this.createUniqueName( cameraDef.name );\r\n\r\n\t\tassignExtrasToUserData( camera, cameraDef );\r\n\r\n\t\treturn Promise.resolve( camera );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\r\n\t * @param {number} skinIndex\r\n\t * @return {Promise<Object>}\r\n\t */\r\n\tloadSkin( skinIndex ) {\r\n\r\n\t\tconst skinDef = this.json.skins[ skinIndex ];\r\n\r\n\t\tconst skinEntry = { joints: skinDef.joints };\r\n\r\n\t\tif ( skinDef.inverseBindMatrices === undefined ) {\r\n\r\n\t\t\treturn Promise.resolve( skinEntry );\r\n\r\n\t\t}\r\n\r\n\t\treturn this.getDependency( 'accessor', skinDef.inverseBindMatrices ).then( function ( accessor ) {\r\n\r\n\t\t\tskinEntry.inverseBindMatrices = accessor;\r\n\r\n\t\t\treturn skinEntry;\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\r\n\t * @param {number} animationIndex\r\n\t * @return {Promise<AnimationClip>}\r\n\t */\r\n\tloadAnimation( animationIndex ) {\r\n\r\n\t\tconst json = this.json;\r\n\r\n\t\tconst animationDef = json.animations[ animationIndex ];\r\n\r\n\t\tconst pendingNodes = [];\r\n\t\tconst pendingInputAccessors = [];\r\n\t\tconst pendingOutputAccessors = [];\r\n\t\tconst pendingSamplers = [];\r\n\t\tconst pendingTargets = [];\r\n\r\n\t\tfor ( let i = 0, il = animationDef.channels.length; i < il; i ++ ) {\r\n\r\n\t\t\tconst channel = animationDef.channels[ i ];\r\n\t\t\tconst sampler = animationDef.samplers[ channel.sampler ];\r\n\t\t\tconst target = channel.target;\r\n\t\t\tconst name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.\r\n\t\t\tconst input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;\r\n\t\t\tconst output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;\r\n\r\n\t\t\tpendingNodes.push( this.getDependency( 'node', name ) );\r\n\t\t\tpendingInputAccessors.push( this.getDependency( 'accessor', input ) );\r\n\t\t\tpendingOutputAccessors.push( this.getDependency( 'accessor', output ) );\r\n\t\t\tpendingSamplers.push( sampler );\r\n\t\t\tpendingTargets.push( target );\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.all( [\r\n\r\n\t\t\tPromise.all( pendingNodes ),\r\n\t\t\tPromise.all( pendingInputAccessors ),\r\n\t\t\tPromise.all( pendingOutputAccessors ),\r\n\t\t\tPromise.all( pendingSamplers ),\r\n\t\t\tPromise.all( pendingTargets )\r\n\r\n\t\t] ).then( function ( dependencies ) {\r\n\r\n\t\t\tconst nodes = dependencies[ 0 ];\r\n\t\t\tconst inputAccessors = dependencies[ 1 ];\r\n\t\t\tconst outputAccessors = dependencies[ 2 ];\r\n\t\t\tconst samplers = dependencies[ 3 ];\r\n\t\t\tconst targets = dependencies[ 4 ];\r\n\r\n\t\t\tconst tracks = [];\r\n\r\n\t\t\tfor ( let i = 0, il = nodes.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tconst node = nodes[ i ];\r\n\t\t\t\tconst inputAccessor = inputAccessors[ i ];\r\n\t\t\t\tconst outputAccessor = outputAccessors[ i ];\r\n\t\t\t\tconst sampler = samplers[ i ];\r\n\t\t\t\tconst target = targets[ i ];\r\n\r\n\t\t\t\tif ( node === undefined ) continue;\r\n\r\n\t\t\t\tnode.updateMatrix();\r\n\t\t\t\tnode.matrixAutoUpdate = true;\r\n\r\n\t\t\t\tlet TypedKeyframeTrack;\r\n\r\n\t\t\t\tswitch ( PATH_PROPERTIES[ target.path ] ) {\r\n\r\n\t\t\t\t\tcase PATH_PROPERTIES.weights:\r\n\r\n\t\t\t\t\t\tTypedKeyframeTrack = NumberKeyframeTrack;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase PATH_PROPERTIES.rotation:\r\n\r\n\t\t\t\t\t\tTypedKeyframeTrack = QuaternionKeyframeTrack;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase PATH_PROPERTIES.position:\r\n\t\t\t\t\tcase PATH_PROPERTIES.scale:\r\n\t\t\t\t\tdefault:\r\n\r\n\t\t\t\t\t\tTypedKeyframeTrack = VectorKeyframeTrack;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst targetName = node.name ? node.name : node.uuid;\r\n\r\n\t\t\t\tconst interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : InterpolateLinear;\r\n\r\n\t\t\t\tconst targetNames = [];\r\n\r\n\t\t\t\tif ( PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.weights ) {\r\n\r\n\t\t\t\t\tnode.traverse( function ( object ) {\r\n\r\n\t\t\t\t\t\tif ( object.morphTargetInfluences ) {\r\n\r\n\t\t\t\t\t\t\ttargetNames.push( object.name ? object.name : object.uuid );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttargetNames.push( targetName );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet outputArray = outputAccessor.array;\r\n\r\n\t\t\t\tif ( outputAccessor.normalized ) {\r\n\r\n\t\t\t\t\tconst scale = getNormalizedComponentScale( outputArray.constructor );\r\n\t\t\t\t\tconst scaled = new Float32Array( outputArray.length );\r\n\r\n\t\t\t\t\tfor ( let j = 0, jl = outputArray.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\tscaled[ j ] = outputArray[ j ] * scale;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\toutputArray = scaled;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( let j = 0, jl = targetNames.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tconst track = new TypedKeyframeTrack(\r\n\t\t\t\t\t\ttargetNames[ j ] + '.' + PATH_PROPERTIES[ target.path ],\r\n\t\t\t\t\t\tinputAccessor.array,\r\n\t\t\t\t\t\toutputArray,\r\n\t\t\t\t\t\tinterpolation\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\t// Override interpolation with custom factory method.\r\n\t\t\t\t\tif ( sampler.interpolation === 'CUBICSPLINE' ) {\r\n\r\n\t\t\t\t\t\ttrack.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) {\r\n\r\n\t\t\t\t\t\t\t// A CUBICSPLINE keyframe in glTF has three output values for each input value,\r\n\t\t\t\t\t\t\t// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\r\n\t\t\t\t\t\t\t// must be divided by three to get the interpolant's sampleSize argument.\r\n\r\n\t\t\t\t\t\t\tconst interpolantType = ( this instanceof QuaternionKeyframeTrack ) ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;\r\n\r\n\t\t\t\t\t\t\treturn new interpolantType( this.times, this.values, this.getValueSize() / 3, result );\r\n\r\n\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\t// Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.\r\n\t\t\t\t\t\ttrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttracks.push( track );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst name = animationDef.name ? animationDef.name : 'animation_' + animationIndex;\r\n\r\n\t\t\treturn new AnimationClip( name, undefined, tracks );\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\tcreateNodeMesh( nodeIndex ) {\r\n\r\n\t\tconst json = this.json;\r\n\t\tconst parser = this;\r\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\r\n\r\n\t\tif ( nodeDef.mesh === undefined ) return null;\r\n\r\n\t\treturn parser.getDependency( 'mesh', nodeDef.mesh ).then( function ( mesh ) {\r\n\r\n\t\t\tconst node = parser._getNodeRef( parser.meshCache, nodeDef.mesh, mesh );\r\n\r\n\t\t\t// if weights are provided on the node, override weights on the mesh.\r\n\t\t\tif ( nodeDef.weights !== undefined ) {\r\n\r\n\t\t\t\tnode.traverse( function ( o ) {\r\n\r\n\t\t\t\t\tif ( ! o.isMesh ) return;\r\n\r\n\t\t\t\t\tfor ( let i = 0, il = nodeDef.weights.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\to.morphTargetInfluences[ i ] = nodeDef.weights[ i ];\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn node;\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\r\n\t * @param {number} nodeIndex\r\n\t * @return {Promise<Object3D>}\r\n\t */\r\n\tloadNode( nodeIndex ) {\r\n\r\n\t\tconst json = this.json;\r\n\t\tconst extensions = this.extensions;\r\n\t\tconst parser = this;\r\n\r\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\r\n\r\n\t\t// reserve node's name before its dependencies, so the root has the intended name.\r\n\t\tconst nodeName = nodeDef.name ? parser.createUniqueName( nodeDef.name ) : '';\r\n\r\n\t\treturn ( function () {\r\n\r\n\t\t\tconst pending = [];\r\n\r\n\t\t\tconst meshPromise = parser._invokeOne( function ( ext ) {\r\n\r\n\t\t\t\treturn ext.createNodeMesh && ext.createNodeMesh( nodeIndex );\r\n\r\n\t\t\t} );\r\n\r\n\t\t\tif ( meshPromise ) {\r\n\r\n\t\t\t\tpending.push( meshPromise );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( nodeDef.camera !== undefined ) {\r\n\r\n\t\t\t\tpending.push( parser.getDependency( 'camera', nodeDef.camera ).then( function ( camera ) {\r\n\r\n\t\t\t\t\treturn parser._getNodeRef( parser.cameraCache, nodeDef.camera, camera );\r\n\r\n\t\t\t\t} ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tparser._invokeAll( function ( ext ) {\r\n\r\n\t\t\t\treturn ext.createNodeAttachment && ext.createNodeAttachment( nodeIndex );\r\n\r\n\t\t\t} ).forEach( function ( promise ) {\r\n\r\n\t\t\t\tpending.push( promise );\r\n\r\n\t\t\t} );\r\n\r\n\t\t\treturn Promise.all( pending );\r\n\r\n\t\t}() ).then( function ( objects ) {\r\n\r\n\t\t\tlet node;\r\n\r\n\t\t\t// .isBone isn't in glTF spec. See ._markDefs\r\n\t\t\tif ( nodeDef.isBone === true ) {\r\n\r\n\t\t\t\tnode = new Bone();\r\n\r\n\t\t\t} else if ( objects.length > 1 ) {\r\n\r\n\t\t\t\tnode = new Group();\r\n\r\n\t\t\t} else if ( objects.length === 1 ) {\r\n\r\n\t\t\t\tnode = objects[ 0 ];\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tnode = new Object3D();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( node !== objects[ 0 ] ) {\r\n\r\n\t\t\t\tfor ( let i = 0, il = objects.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tnode.add( objects[ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( nodeDef.name ) {\r\n\r\n\t\t\t\tnode.userData.name = nodeDef.name;\r\n\t\t\t\tnode.name = nodeName;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tassignExtrasToUserData( node, nodeDef );\r\n\r\n\t\t\tif ( nodeDef.extensions ) addUnknownExtensionsToUserData( extensions, node, nodeDef );\r\n\r\n\t\t\tif ( nodeDef.matrix !== undefined ) {\r\n\r\n\t\t\t\tconst matrix = new Matrix4();\r\n\t\t\t\tmatrix.fromArray( nodeDef.matrix );\r\n\t\t\t\tnode.applyMatrix4( matrix );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( nodeDef.translation !== undefined ) {\r\n\r\n\t\t\t\t\tnode.position.fromArray( nodeDef.translation );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( nodeDef.rotation !== undefined ) {\r\n\r\n\t\t\t\t\tnode.quaternion.fromArray( nodeDef.rotation );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( nodeDef.scale !== undefined ) {\r\n\r\n\t\t\t\t\tnode.scale.fromArray( nodeDef.scale );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! parser.associations.has( node ) ) {\r\n\r\n\t\t\t\tparser.associations.set( node, {} );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tparser.associations.get( node ).nodes = nodeIndex;\r\n\r\n\t\t\treturn node;\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\r\n\t * @param {number} sceneIndex\r\n\t * @return {Promise<Group>}\r\n\t */\r\n\tloadScene( sceneIndex ) {\r\n\r\n\t\tconst json = this.json;\r\n\t\tconst extensions = this.extensions;\r\n\t\tconst sceneDef = this.json.scenes[ sceneIndex ];\r\n\t\tconst parser = this;\r\n\r\n\t\t// Loader returns Group, not Scene.\r\n\t\t// See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172\r\n\t\tconst scene = new Group();\r\n\t\tif ( sceneDef.name ) scene.name = parser.createUniqueName( sceneDef.name );\r\n\r\n\t\tassignExtrasToUserData( scene, sceneDef );\r\n\r\n\t\tif ( sceneDef.extensions ) addUnknownExtensionsToUserData( extensions, scene, sceneDef );\r\n\r\n\t\tconst nodeIds = sceneDef.nodes || [];\r\n\r\n\t\tconst pending = [];\r\n\r\n\t\tfor ( let i = 0, il = nodeIds.length; i < il; i ++ ) {\r\n\r\n\t\t\tpending.push( buildNodeHierarchy( nodeIds[ i ], scene, json, parser ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.all( pending ).then( function () {\r\n\r\n\t\t\t// Removes dangling associations, associations that reference a node that\r\n\t\t\t// didn't make it into the scene.\r\n\t\t\tconst reduceAssociations = ( node ) => {\r\n\r\n\t\t\t\tconst reducedAssociations = new Map();\r\n\r\n\t\t\t\tfor ( const [ key, value ] of parser.associations ) {\r\n\r\n\t\t\t\t\tif ( key instanceof Material || key instanceof Texture ) {\r\n\r\n\t\t\t\t\t\treducedAssociations.set( key, value );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tnode.traverse( ( node ) => {\r\n\r\n\t\t\t\t\tconst mappings = parser.associations.get( node );\r\n\r\n\t\t\t\t\tif ( mappings != null ) {\r\n\r\n\t\t\t\t\t\treducedAssociations.set( node, mappings );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t\treturn reducedAssociations;\r\n\r\n\t\t\t};\r\n\r\n\t\t\tparser.associations = reduceAssociations( scene );\r\n\r\n\t\t\treturn scene;\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction buildNodeHierarchy( nodeId, parentObject, json, parser ) {\r\n\r\n\tconst nodeDef = json.nodes[ nodeId ];\r\n\r\n\treturn parser.getDependency( 'node', nodeId ).then( function ( node ) {\r\n\r\n\t\tif ( nodeDef.skin === undefined ) return node;\r\n\r\n\t\t// build skeleton here as well\r\n\r\n\t\tlet skinEntry;\r\n\r\n\t\treturn parser.getDependency( 'skin', nodeDef.skin ).then( function ( skin ) {\r\n\r\n\t\t\tskinEntry = skin;\r\n\r\n\t\t\tconst pendingJoints = [];\r\n\r\n\t\t\tfor ( let i = 0, il = skinEntry.joints.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tpendingJoints.push( parser.getDependency( 'node', skinEntry.joints[ i ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn Promise.all( pendingJoints );\r\n\r\n\t\t} ).then( function ( jointNodes ) {\r\n\r\n\t\t\tnode.traverse( function ( mesh ) {\r\n\r\n\t\t\t\tif ( ! mesh.isMesh ) return;\r\n\r\n\t\t\t\tconst bones = [];\r\n\t\t\t\tconst boneInverses = [];\r\n\r\n\t\t\t\tfor ( let j = 0, jl = jointNodes.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tconst jointNode = jointNodes[ j ];\r\n\r\n\t\t\t\t\tif ( jointNode ) {\r\n\r\n\t\t\t\t\t\tbones.push( jointNode );\r\n\r\n\t\t\t\t\t\tconst mat = new Matrix4();\r\n\r\n\t\t\t\t\t\tif ( skinEntry.inverseBindMatrices !== undefined ) {\r\n\r\n\t\t\t\t\t\t\tmat.fromArray( skinEntry.inverseBindMatrices.array, j * 16 );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tboneInverses.push( mat );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Joint \"%s\" could not be found.', skinEntry.joints[ j ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tmesh.bind( new Skeleton( bones, boneInverses ), mesh.matrixWorld );\r\n\r\n\t\t\t} );\r\n\r\n\t\t\treturn node;\r\n\r\n\t\t} );\r\n\r\n\t} ).then( function ( node ) {\r\n\r\n\t\t// build node hierachy\r\n\r\n\t\tparentObject.add( node );\r\n\r\n\t\tconst pending = [];\r\n\r\n\t\tif ( nodeDef.children ) {\r\n\r\n\t\t\tconst children = nodeDef.children;\r\n\r\n\t\t\tfor ( let i = 0, il = children.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tconst child = children[ i ];\r\n\t\t\t\tpending.push( buildNodeHierarchy( child, node, json, parser ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.all( pending );\r\n\r\n\t} );\r\n\r\n}\r\n\r\n/**\r\n * @param {BufferGeometry} geometry\r\n * @param {GLTF.Primitive} primitiveDef\r\n * @param {GLTFParser} parser\r\n */\r\nfunction computeBounds( geometry, primitiveDef, parser ) {\r\n\r\n\tconst attributes = primitiveDef.attributes;\r\n\r\n\tconst box = new Box3();\r\n\r\n\tif ( attributes.POSITION !== undefined ) {\r\n\r\n\t\tconst accessor = parser.json.accessors[ attributes.POSITION ];\r\n\r\n\t\tconst min = accessor.min;\r\n\t\tconst max = accessor.max;\r\n\r\n\t\t// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\r\n\r\n\t\tif ( min !== undefined && max !== undefined ) {\r\n\r\n\t\t\tbox.set(\r\n\t\t\t\tnew Vector3( min[ 0 ], min[ 1 ], min[ 2 ] ),\r\n\t\t\t\tnew Vector3( max[ 0 ], max[ 1 ], max[ 2 ] )\r\n\t\t\t);\r\n\r\n\t\t\tif ( accessor.normalized ) {\r\n\r\n\t\t\t\tconst boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );\r\n\t\t\t\tbox.min.multiplyScalar( boxScale );\r\n\t\t\t\tbox.max.multiplyScalar( boxScale );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\treturn;\r\n\r\n\t}\r\n\r\n\tconst targets = primitiveDef.targets;\r\n\r\n\tif ( targets !== undefined ) {\r\n\r\n\t\tconst maxDisplacement = new Vector3();\r\n\t\tconst vector = new Vector3();\r\n\r\n\t\tfor ( let i = 0, il = targets.length; i < il; i ++ ) {\r\n\r\n\t\t\tconst target = targets[ i ];\r\n\r\n\t\t\tif ( target.POSITION !== undefined ) {\r\n\r\n\t\t\t\tconst accessor = parser.json.accessors[ target.POSITION ];\r\n\t\t\t\tconst min = accessor.min;\r\n\t\t\t\tconst max = accessor.max;\r\n\r\n\t\t\t\t// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\r\n\r\n\t\t\t\tif ( min !== undefined && max !== undefined ) {\r\n\r\n\t\t\t\t\t// we need to get max of absolute components because target weight is [-1,1]\r\n\t\t\t\t\tvector.setX( Math.max( Math.abs( min[ 0 ] ), Math.abs( max[ 0 ] ) ) );\r\n\t\t\t\t\tvector.setY( Math.max( Math.abs( min[ 1 ] ), Math.abs( max[ 1 ] ) ) );\r\n\t\t\t\t\tvector.setZ( Math.max( Math.abs( min[ 2 ] ), Math.abs( max[ 2 ] ) ) );\r\n\r\n\r\n\t\t\t\t\tif ( accessor.normalized ) {\r\n\r\n\t\t\t\t\t\tconst boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );\r\n\t\t\t\t\t\tvector.multiplyScalar( boxScale );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative\r\n\t\t\t\t\t// to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets\r\n\t\t\t\t\t// are used to implement key-frame animations and as such only two are active at a time - this results in very large\r\n\t\t\t\t\t// boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.\r\n\t\t\t\t\tmaxDisplacement.max( vector );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.\r\n\t\tbox.expandByVector( maxDisplacement );\r\n\r\n\t}\r\n\r\n\tgeometry.boundingBox = box;\r\n\r\n\tconst sphere = new Sphere();\r\n\r\n\tbox.getCenter( sphere.center );\r\n\tsphere.radius = box.min.distanceTo( box.max ) / 2;\r\n\r\n\tgeometry.boundingSphere = sphere;\r\n\r\n}\r\n\r\n/**\r\n * @param {BufferGeometry} geometry\r\n * @param {GLTF.Primitive} primitiveDef\r\n * @param {GLTFParser} parser\r\n * @return {Promise<BufferGeometry>}\r\n */\r\nfunction addPrimitiveAttributes( geometry, primitiveDef, parser ) {\r\n\r\n\tconst attributes = primitiveDef.attributes;\r\n\r\n\tconst pending = [];\r\n\r\n\tfunction assignAttributeAccessor( accessorIndex, attributeName ) {\r\n\r\n\t\treturn parser.getDependency( 'accessor', accessorIndex )\r\n\t\t\t.then( function ( accessor ) {\r\n\r\n\t\t\t\tgeometry.setAttribute( attributeName, accessor );\r\n\r\n\t\t\t} );\r\n\r\n\t}\r\n\r\n\tfor ( const gltfAttributeName in attributes ) {\r\n\r\n\t\tconst threeAttributeName = ATTRIBUTES[ gltfAttributeName ] || gltfAttributeName.toLowerCase();\r\n\r\n\t\t// Skip attributes already provided by e.g. Draco extension.\r\n\t\tif ( threeAttributeName in geometry.attributes ) continue;\r\n\r\n\t\tpending.push( assignAttributeAccessor( attributes[ gltfAttributeName ], threeAttributeName ) );\r\n\r\n\t}\r\n\r\n\tif ( primitiveDef.indices !== undefined && ! geometry.index ) {\r\n\r\n\t\tconst accessor = parser.getDependency( 'accessor', primitiveDef.indices ).then( function ( accessor ) {\r\n\r\n\t\t\tgeometry.setIndex( accessor );\r\n\r\n\t\t} );\r\n\r\n\t\tpending.push( accessor );\r\n\r\n\t}\r\n\r\n\tassignExtrasToUserData( geometry, primitiveDef );\r\n\r\n\tcomputeBounds( geometry, primitiveDef, parser );\r\n\r\n\treturn Promise.all( pending ).then( function () {\r\n\r\n\t\treturn primitiveDef.targets !== undefined\r\n\t\t\t? addMorphTargets( geometry, primitiveDef.targets, parser )\r\n\t\t\t: geometry;\r\n\r\n\t} );\r\n\r\n}\r\n\r\n/**\r\n * @param {BufferGeometry} geometry\r\n * @param {Number} drawMode\r\n * @return {BufferGeometry}\r\n */\r\nfunction toTrianglesDrawMode( geometry, drawMode ) {\r\n\r\n\tlet index = geometry.getIndex();\r\n\r\n\t// generate index if not present\r\n\r\n\tif ( index === null ) {\r\n\r\n\t\tconst indices = [];\r\n\r\n\t\tconst position = geometry.getAttribute( 'position' );\r\n\r\n\t\tif ( position !== undefined ) {\r\n\r\n\t\t\tfor ( let i = 0; i < position.count; i ++ ) {\r\n\r\n\t\t\t\tindices.push( i );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.setIndex( indices );\r\n\t\t\tindex = geometry.getIndex();\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconsole.error( 'THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );\r\n\t\t\treturn geometry;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tconst numberOfTriangles = index.count - 2;\r\n\tconst newIndices = [];\r\n\r\n\tif ( drawMode === TriangleFanDrawMode ) {\r\n\r\n\t\t// gl.TRIANGLE_FAN\r\n\r\n\t\tfor ( let i = 1; i <= numberOfTriangles; i ++ ) {\r\n\r\n\t\t\tnewIndices.push( index.getX( 0 ) );\r\n\t\t\tnewIndices.push( index.getX( i ) );\r\n\t\t\tnewIndices.push( index.getX( i + 1 ) );\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\t// gl.TRIANGLE_STRIP\r\n\r\n\t\tfor ( let i = 0; i < numberOfTriangles; i ++ ) {\r\n\r\n\t\t\tif ( i % 2 === 0 ) {\r\n\r\n\t\t\t\tnewIndices.push( index.getX( i ) );\r\n\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\r\n\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\r\n\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\r\n\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\r\n\t\t\t\tnewIndices.push( index.getX( i ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tif ( ( newIndices.length / 3 ) !== numberOfTriangles ) {\r\n\r\n\t\tconsole.error( 'THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );\r\n\r\n\t}\r\n\r\n\t// build final geometry\r\n\r\n\tconst newGeometry = geometry.clone();\r\n\tnewGeometry.setIndex( newIndices );\r\n\r\n\treturn newGeometry;\r\n\r\n}\r\n\r\nexport { GLTFLoader };\r\n"],
  "mappings": "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",
  "names": []
}
